## 第二章 消息传递系统中基本算法
本章研究的是**无故障**的**msg传递系统**,考虑两种主要的记时模型:**同步/异步**
### 2.1 消息传递系统的形式化模型
#### 2.1.1.1 系统
(下面介绍一些相关的基本概念)
拓扑结构、算法、状态、初始状态、转化函数、配置、事件、执行、安全性条件、活跃性条件

##### 拓扑结构
无向图,结点代表处理机;边代表**双向**信道

##### 算法
由每个处理机上的局部程序构成,**局部程序**包括
>+ 执行局部计算--本地处理器
>+ 发送/接受msg--邻居结点
>+ PS:假设一个系统/算法由n个处理器p0,p1,...,pn构成,每个处理器Pi各异模型化为一个具有状态集Qj的状态机


##### 状态 
由pi的变量,pi的msgs构成,pi的每个状态由2r个msg构成(r为邻居个数)
>+ $outbuf_i[l](1\leq l\leq r)$:表示pi经第l条关联的信道发送给邻居,但还未传到邻居的msg
>+ $inbuf_i[l](1\leq l\leq r)$:表示pi的第l条信道上已传递到pi,但未经pi计算处理的msg
>+ PS:上述过程模拟信道上传输的msgs

##### 初始状态
Qj包含一个特殊的初始状态子集,每个$inbuf_i[l]$为空,但$outbuf_i[l]$不一定为空.

##### 转换函数
处理器pi的转换函数,实际上是一个局部程序,将输入缓冲区中的信息情况并产生输出
>+ 输入:pi的可访问状态 **(?存疑,可访问状态定义)**
>+ 输出:对每个信道l,至多产生一个msg输出
>+ PS:转换函数使 **输入缓冲区清空**

##### 配置
配置是分布式系统在某点上整个算法的**全局状态**
>定义向量=(q0,q1,...,qn-1)qi是pi的一个状态(qi是上述提及的处理机pi的一个状态)
一个配置中outbuf变量的状态表示在通信信道上传输的信息,由del时间模拟传输
对于初始配置向量,其中每一个qi是pi的厨师状态,即每个处理器均处于初始状态.

##### 事件
系统中发生的事情模型化为事件,对于msg传递系统中主要分为两种:
>+ comp(i)--计算事件,代表处理器pi的一个计算步骤,其中pi转换函数被用于当前可访问状态
>+ del(i,j,m)传递事件,表示msg m从pi传递到pj

##### 执行
系统在事件上的行为被模型话为一个执行,由一个配置和事件交错的序列该序列满足各种条件主要分为以下两种:
>+ Safety条件(安全性条件):表示某个性质在**每次执行**中每个**可到达配置**里必须成立(在序列的每个优先前缀里必须成立的条件),从非形式化语言表示:坏事从不发生
>+ liveness条件:(活跃性条件)
表示某个性质在每次执行中的某些可达配置里必须成立,必须成立一定次数的条件,非形式化的语言描述:最终某个好事将会发生

对于特定系统满足要求的安全性条件的序列称之为一个**执行**,若一个执行也满足要求的活跃性条件,责备成为**容许(合法)执行**

##### 板书补充:
符号表:
|符号|对应含义|例子|
|---|---|---|
|$S$|转移系统|$S=(C,\to,I)$|
|$C$|配置集|$S=(C,\to,I)$|
|$\to$|C上的一个二元转移符,是C*C的一个子集|$S=(C,\to,I)$|
|$I$|初始配置的一个子集,其中$r_0\in I$|$S=(C,\to,I)$|
|$r_i$|一个配置|$E=(r_0,r_1,...,),r_0\in I$|
|$E$|一次执行的序列|$E=(r_0,r_1,...,)$|


##### 安全性条件补充:
$\{P\} \to \{Q\}$表示对于每一次转移$r\to S$,如果转移前任一阶段P均成立则Q在转移后成立
**定义1:** 对于所有$r\in I,P(r)成立且\{P_i\}\to \{P_{i+1}\}$,断言P总是成立,在每个初始配置中断言P总是成立,并且在每一次转移中保持不变,因此在每个可达配置中不变式成立,隐含条件,**对于可从初始状态不可达状态转移的不变式也成立(定理2).**
**定义2:** S为转移系统,P,Q为断言,对于所有$r\in I,Q(r)\to P(r)且\{Q\& P\}\to \{Q\to P\}$,表示$\{Q\& P\}$在转移前成立,$\{Q\to P\}$在转移后成立,则称P是Q的一导出的(当Q为不变式且,时退化为定理2)

**定理1:** 如果P是S的一个不变式,那么对于S的每次执行的每一配置,P均成立
**定理2:** 设Q是S的不变式,设$Q\to P$对于每一个$r\in C$, P在每一执行的每一配置中均成立.
**定理3:** 如Q是S的不变式,P式Q的一级导出,那么$P\&Q$也是不变式

##### 活跃性条件补充:
在算法的每次执行的某次配置中,断言P为真或断言P最终为真
证明断言P最终为真的基本技术:1.范函数 2.无死锁,正常终止

设S为转移系统,P为一个谓词,term也是一个谓词,并在所有最终配置中为真,我们P为设置两种状态:
>+ 不能到达目标P,此时为假 (**?怎么定义目标状态,对于良基集合是否基即为我们要求的目标状态**)
>+ 目标p已达到,此时为真

term两种状态:
>+ 死锁,为假
>+ 能正常终止,为真

当死锁发生时term为假,term为真
**定义1:** 如果谓词term=>P在S中总是为真,则S正常终止(无死锁)
**定义2:** 给定一个偏序集$(W,<)$不存在无穷递减序列,则称该序列为良基集
**定义3:** 给定转移系统S和断言P,称C到良基集W的函数f为范函数(关于P)

**定理1:** 给定转移系统S和断言P,如果S正常终止,且范函数存在,那么在S的每次执行的某些配置中P为真
**定理2:** 如果S正常终止,且存在数K,满足每次执行至多包含K次转移,那么在每次执行的某些配置中,P为真

PS:证明大致思路 有限=>良基=>范函数=>P为真

---
**<font color=red>下面提及的概念为异步系统中的概念,跟上述概念有部分重复但有所不同,注意区分 </font>**
#### 2.1.1.2 异步系统

主要包含:异步系统、执行片段、执行、调度、容许执行、容许调度

##### 异步系统:
msg传递事件与处理器两个相邻步骤之间的时间无固定上界.例:e-mail传递时可能需要数天,因此设计异步算法时需要特殊的计时参数,不能依赖该上界.

##### 执行片段:
对于一个异步msg传递系统,执行片段$\alpha$是一个有限/无限序列:
$$
C_0,\phi_1,C_1,\phi2,C_2,\phi_3,...,(C_0不一定为初始配置)
$$
上述序列中$C_k$是一个配置,$\phi_k$是一个时间,若$\alpha$有限,则必须终止于某个配置且满足下述条件:
>**1.若$\phi_k=del(i,j,k):$** 则m必是$C_{k-1}$里outbuf_i[l]的一个元素,l是pi信道{pi,pj}中的下标标号,从$C_{k-1}到C_k$发生的变化是将m从C_{k-1}从$C_{k-1}$中山区,并将其加入到$C_k$里的$inbuf_j[h]$中,同理h为pj的信道{p_i,p_j}的标号.
**即:上述过程完成将msg从发送者输出缓冲区(outbuf)转移到接收者的输入缓冲区(inbuf)**
**2.若$\phi_k=comp(i):$** 则配置$C_{k-1}到C_k$发生的变化为:
>>1.改变状态:转换函数在$p_i$的可访问状态上进行操作,清空$inbuf_i[l]$
>>2.发送msg:将转换函数指定的信息集合加到$C_k$的$outbuf_i$中
>**即:上述操作完成将节点pi在$C_{k-1}$状态作为基础按照转换函数改变状态并发出msg**
>
>PS:
操作一为数据传输操作,表示将某个节点待发送的信息,发送到对应节点的过程
操作二实现计算操作,将某节点的输入信息清空,并依此计算对应的输出结果,并将对应的输出信息准备放到输出缓冲区,等待操作一进行数据传输和分发


##### 执行:
执行是一个执行片段:
$$
C_0,\phi_1,C_1,\phi2,C_2,\phi_3,...
$$
但是要求此时 **$C_0$必须为初始配置**

##### 调度:
通常情况下一个调度通常是指在某次执行(或者执行片段)中执行的事件序列:
$$
\phi_1,\phi_2,\phi_3,...
$$
但是事件序列不都是调度(PPT中举例单个事件del(1,2,m)不是调度,因为没有comp(1)往p1的输出缓冲区中提供信息m)
如果局部程序是**确定的(无随机)**,那么执行可以由**初始配置$C_0$以及调度唯一确定**,我们表示为 $exec(C_0,\sigma)$

##### 容许执行:(满足活跃性条件(好事终会发生))
对于拥有无限计算事件的异步系统中来说,其容许执行表示每个计算的msg都最终被传递 **(处理器无出错)** 但不包含处理器的局部程序必须包括一个**无限循环**(?存疑)
非形式化的表示:一个算法终止的条件是在某点后**转换函数不改变处理器的状态**

##### 容许的调度:
当它是一个容许执行的一个调度

---

**<font color=red>下面提及的概念为同步系统中的概念,跟上述概念有部分重复但有所不同,注意区分 </font>**
#### 2.1.1.3 同步系统
主要包含:同步系统、轮、容许的执行、同步系统与异步系统的区别
##### 同步系统
处理器按锁步骤进行执行(lock-step):执行划分为若干轮,每轮能够进行下面两种操作:
>+ 每个处理器能够发送一个msg到其邻居节点
>+ 每个处理器一接到msg就进行计算

PS:这种特殊的分布式系统**一般情况下无法达到**,按时该模型对于设计算法相对简单,因此可以先按该模型进行算法设计,然后改写为对应的异步算法.

##### 轮
在同步系统中,配置与事件序列可以划分为不相交的轮,**每轮由一个传递事件以及一个计算事件组成**(先进行消息的传递,后进行计算任务处理传递的信息)

##### 容许的执行:
指无限的执行,因为轮的结构因此每个处理器可以**执行无限数目的计算步**,同时每个被发送的**msg最终被传递**

#### 2.1.1.4 同步与异步系统的区别:
在一个无措的同步系统中,**一个算法的执行只取决于初始配置(同步系统)**,但在异步系统中对于相同的初始配置以及无错假定,**由于处理器步骤间隔以及消息延迟的不确定性,因此对于相同算法可能由不同的执行.**

---
### 2.1.2 复杂性度量
#### 分布式算法的性能(评价指标):
主要由下面的度量方式:
>+ 消息复杂度
>+ 时间复杂度
>+ 空间复杂度
>+ 性能衡量:最坏性能,期望性能

#### 终止
假定每个处理器的状态集包括终止状态子集,每个$p_i$的转换函数对**终止状态只能映射到终止状态**,当**所有处理机均处于终止状态且没有msg在传输时**,称系统已经结束

#### 算法的msg复杂性(最坏情况)
算法在所有容许执行上发送的msg总数的最大值(包括同步系统以及异步系统)

#### 复杂度度量
消息复杂度:
1.消息总数
2.消息中总的位数长度

#### 时间复杂度
**同步系统:** 最大轮数,算法的任何容许执行知道终止的**最大轮数**
**异步系统:** 首先我们基于下面两个假设
>+ 假设1.节点计算任何有限数目事件的时间为0
>+ 假设2.消息发送和接受之间的时间假设为1

那么基于上述两个假设的情况下,异步系统的时间复杂度为所有计时容许执行中到终止的最大时间.

#### 计时执行(timed execution)
每个事件关联一个非负实数,表示事件发生的时间,时间起始于0且非递减(**对于单个处理器时严格增的**)
在上述定义的情况下具有该性质:若执行时无限的,则执行的时间时无界的,因此执行的时间可以**根据时间进行排序**
PS:非形式化的理解,同时间一个处理器只能完成一件事,但是此时其他处理器可以处理其他的事情,因此具有相同的时间戳,同时在有限时间内只有有限数目的事件发生

#### 消息的延迟
发送msg的计算时间和处理该msg的计算事件之间所逝去的事件
主要由msg在发送者outbuf中等待事件以及接受者inbuf中的等待时间构成(不考虑传送时间)

#### 异步算法的时间复杂性
定义每个msg延时至多为1(实际中至多1个时间单位会很难计算因此我们修改假设:)
>+ 一条信息发送和接受之间时间恰好为1
>+ 一条消息发送和接受之间时间介于 $\alpha$和1之间($0<\alpha <1$)
>+ 假设消息传递的延迟满足某种概率分布

### 2.1.3伪代码约定
描述算法有两种方式:
>+ 叙述性:对于简单问题
>+ 伪码形式:对于复杂问题

#### 异步算法
对于每个处理器,使用中断驱动的方式来描述异步算法.在形式化模型中每次计算事件处理所有的输入msg,但在算法描述中需要描述**逐个描述msg**是如何处理的.
对于一个计算事件的局部计算描述类似顺序算法的伪代码描述.

#### 同步算法
使用**逐轮描述**

#### 部分默认的约定
在对pi的局部变量进行描述时,无需使用i做下标(讨论和证明中需要加上下标)
//后跟注释

## 2.2 生成树上的广播和汇集
### 概念介绍
**生成树:**
>一个无向联通图G的生成树是指满足下列条件的G的一个子图:
>+ G和T拥有相同的顶点数
>+ T中任意两点联通,且无回路(假设节点个数为n,则边数为n-1)

**最小生成树:**
在生成树的基础上,假设每一条边具有指定权值,那么虽有边权和最小的生成树,我们称之为最小生成树

### 2.2.1 广播(Broadcast)
假设网络的网络生成树已经给定,假设生成树的根为$p_r$,发送的信息为$M$,那么每个处理器有一个信道连接其双亲,其余若干个信道连接其孩子,那么信息传递的过程分成下面两个情况:
>+ 根$p_r$发送M给所有孩子
>+ 某节点收到父节点的$M$时,将$M$发送给所有自己的孩子

#### 伪码算法:
```c++
Alg2.1 Brocast
//下面操作对象为 pr:根节点,假设初始化时M已在传输状态
1 upon receiving no msg: //初始状态根节点发送信息
2   terminate;           //根节点进入终止状态

//下面操作对象为除了跟节点的其他节点即 pi(i!=r,0<=i<=n-1)
1 upon receiving M from parent: //如果接受到从父节点传递的M则进行下面操作
2   send M to all children;     //将信息传递给所有子节点
3   terminate;                  //传递完后该节点进入终止状态
```

#### 状态转换来分析算法
首先我们定义对于处理器$p_i$包含的状态:
>+ 变量$parent_i$: 表示处理器p_i的父节点的标号(当i=r时为nil)
>+ 变量$children_i$:$p_i$的子节点标号的**集合**
>+ 布尔变量terminated: 表示$p_i$是否处于终止状态

#### 过程分析

##### 初始状态:
>+ parent和children由生成树形成时进行确定
>+ 所有terminated设置为假
>+ 对于根节点输出缓冲区$outbuf_r[j],j\in children_r$中存放M信息准备发送,j表示第几个孩子而不是真实的节点序号
>+ 所有其他节点的outbuf变量均为空

##### comp(i)的计算结果
对于某个k,M在$inbuf_i[k]$里时,则M被放到$outbuf_i[j],\forall j\in children_i$

##### $p_i$进入终止状态
将terminated置为true

##### msg复杂度&时间复杂度
msg复杂度:在同步或异步模型中,msgM在生成树的每一条边上恰好发送一次,因此msg复杂性为n-1
时间复杂度:设h为树的高度,复杂度为O(h)

**PS:该算法对同步系统以及异步系统均正确,且在两模型中msg和事件复杂度相同**

#### 广播时间复杂度计算:
##### 对于同步模型:
时间由轮来进行度量
定理2.1:在同步模型中,在广播算法的每个容许执行里,树中每个距离$p_i$为t的处理器在第t轮里接受消息.(证明过程使用归纳法进行证明,此处略)
定理2.2:当生成树高度为d时,存在一个消息复杂度为n-1,时间复杂度为d的同步广播算法

##### 对于异步模型
定理2.3:在异步模型的广播算法的每个容许执行里,树中每个距离为$p_r$为t的处理器,**至多**在时刻t接受消息
定理2.4:同2.2

### 2.2.2 汇聚/敛播(convergecast)
与广播问题相反,汇集是从所有节点收集信息至根节点.简单起见,考虑一个特殊的变种问题,求所有节点的最大值

#### 算法
每个叶子节点$p_j$发送$x_j$至双亲//启动者
对于每个非叶节点$j$,设$p_j$有$k$个孩子,等待$k$个孩子msg均受到之后,将最大值发送回$p_j$的双亲节点
简言之:由叶子节点启动,每个处理器$p_j$计算以自己为根的子树里最大值$v_j$,然后将$v_j$发送回$p_j$的双亲

#### 复杂性
当生成树高为d时,存在一个异步的敛播方法,使得其msg复杂度为n-1,时间复杂度为d
#### 广播/敛播算法用途
初始化某信息的发布(广播),然后使用敛播的方式进行信息的回收

## 2.3 生成树的构造
### Flooding算法(淹没.洪泛算法)
#### 算法简述
设$p_r$为特殊处理器,从$p_r$开始,发送M至所有邻居,当$p_i$第一次收到信息(从$p_j处收到$),则将M发送至除了$p_j$以外的所有邻居节点

#### msg复杂度
由于每个节点在任一信道上发送M不会多于一次,所以每个信道上M至多被发送2次(信道两头处理器各一次),因此最坏情况下除了第一次接受的信道之外,所有其他信道上M被传送2次,因此,需要发送**2\*m-(n-1)** 个msg,m为信道总数,其最多可以达到 **$\frac{n*(n-1)}{2}$** ,因此最坏情况下msg复杂度为$O(n^2)$

#### 时间复杂度:
O(D)D为网的直径(任意两点间距离的最大者)

### 生成树算法(Flooding改造)
#### 基本思想:
>+ 假设$p_r$为根节点
>+ 当$p_i$从某邻居节点收到第一个来自邻居$p_j$的msg时,将$p_j$设为$p_i$的父节点;若存在多个邻居则可以任选一个作为父节点
>+ 当$p_i$确定父节点$p_j$后,发送\<parent>给$p_j$,并对没被选为父节点的处理器发送\<reject>消息
>+ $p_i$对所有没给他发过消息的节点发送M,等待所有节点发送回\<parent>或者\<reject>,那些发回\<parent>的节点为$p_i$的孩子节点
>+ 当$p_i$发出的M都得到回应后,$p_i$进入终止状态,将parent和children的边保留即为生成树
#### 伪代码:
```c++
//Alg构造生成树(code for pj 0<=i<n-1)
//初值:parent=nil;集合children和other为空集
upon receiving no message:
    if(i==r and parent==nil) then{  //初始状态,根还没有发送M
        send M to all neighbors;    //发送消息M给所有子节点
        parent:=i;                   //将根的父节点设为自己
    }

upon receiving M from neighbor pj:  //当pj收到M
    if(parent==nil) then{           //pj还不是生成树的一部分
        parent:=j;                  //设置其父节点
        send <parent> to j;         //发送<parent>确认信息
        send <reject> to all neighbors except pj;   //发送reject信息给其他节点
    }else
        send <reject> to pj;        //说明pj已经有父节点,因此回复reject 
```

#### 分析
**定理2.6:** 在异步模型的每个容许执行中,上述算法构造一棵根为$p_r$的生成树
Proof(证明):
>+ 一旦某节点设置parent变量,则其不会改变,即每个节点只有一个父节点
>+ 处理器的孩子集合不会减小

因此已经确定了的图结构不会改变,同时parent与children关系也不会改变.

证明:为何从根能到达每一节点(联通性)
反证:假设某节点在G中不可由$p_r$可达,因为网络联通,若存在**两个相邻节点**$p_i,p_j$使得 **$p_j$是由$p_r$可达** 的,但 **$p_i$由$p_r$不可达**.因为G里一节点从$p_r$可达当且仅当其设置过自己的parent变量,所以 **$p_i$的parent变量在执行过程中仍为nil**,而由于$p_j$在某点上已经设置过自己的parent变量,因此 **$p_j$回发送M至$p_i$**,因此msg必定被$p_i$接受,并**使得$p_i$将其parent变脸设置为j**,因此矛盾.
**无环性**
假设存在环$p_i,...,p_k,p_i$,若$p_i$为$p_k$的孩子,那么按照该链反推,$p_i$在第一次收到$p_k$发来消息前九接收到其他节点传来的消息.因此矛盾
**复杂性**
对于flooding算法来说,提高了msg复杂性,但仅为常数,因此我们可以得到下面的定理:
**定理2.7:** 对于m条边,直径为D的网络,给定一特殊节点(根),存在一个msg复杂性为$O(m)$,时间复杂性为$O(D)$的异步算法,找到该网络的一颗生成树

算法2.2,在同步模型中仍可工作,且分析类似异步算法,但是其生成的生成树一定为BFS树(因为不考虑数据传输时延迟)
**定理2.8:** 在同步模型下Alg2.2的每次容许执行均构造一颗BFS树
证明过程使用归纳法证明(略)
归纳条件如下:
假设当前为t轮
>+ 在第t轮开始时当时图是一颗离根节点距离至多t-1的BFS树
>+ 当前传输信息的M仅来自距离为为t-1的节点传播


**定理2.9:** 对于具有m条边直径为D的网络,给定一个特殊节点,存在一个msg复杂度为$O(m)$,时间复杂度为$O(D)$

异步系统中是否能生成BFS树?
由于消息传递存在延迟,因此即使虽然图直径为1,但异步系统根据收到消息时间生成树,生成的图不一定为BFS树.

#### 汇总
信息的请求和收集,我们可以将生成树手机还有信息汇聚算法组合.假设生成的图为完全图:
那么对于生成树算法,同步与异步消息复杂度为$O(m)$,时间复杂度为$O(D$
对于汇聚算法,同步与异步均有,消息复杂度为$O(n-1)$,时间复杂度为$O(d)$,d为树高
对于组合算法,我们很容易得到由于同步算法生成的是BFS树(因为完全图)因此对于BFS树来说树高d=1,D=1,因此此时同步算法较异步算法更加高效

### DFS生成树的构造(指定根)
#### 基本思想
>+ 设定$P_r$为指定的根结点,$P_r$从还未向其发送消息的邻接节点中任选一个发送消息\<m>.
>+ 当$P_i$从$P_j$收到消息\<m>是第一个来自于邻接节点的消息时,$P_j$为$P_i$的双亲,向其发送\<parent>消息后,对所有之后对其发送消息的其他节点发送\<reject>
>+ 当$P_i$还未发送消息的邻居中任选一个,发送消息\<m>,等待回复\<reject>或者\<parent>消息,并将发送\<parent>的节点加入到自己的孩子中
>+ 当$P_i$向所有邻居节点都发送过消息后,$P_i$终止

#### 伪代码:
```c++
//Alg构造生成树,Pr为根
//Code for processor Pi,0<=i<=n-1
//变量定义:
var parent:init nil;    //指示其父节点
    children:init {};   //指示其孩子节点(集合)
    unexplored: init all the neighbors of Pi;   //还未发消息的邻居集合


upon receiving no message:  //根结点
    if(i==r and parent==nil) then{  //初始状态,根还没有发送M
        parent:=i;                  //将根的父节点设为自己
        while(unexplored != {}){    //unexplored 集合非空
            get pj in unexplored;   //从该集合中获取一个元素
            delete pj from unexplored;              //从unexplored 中删除pj(因为之后将发送消息)
            send M to pj;           //给pj发送消息
        }
    }

upon receiving M from neighbor pj:  //当pj收到M
    if(parent==nil) then{           //pj还不是生成树的一部分
        parent:=j;                  //设置其父节点
        delete pj from unexplored;  //在unexplored 中删除pj,因为已经发送过消息
        while(unexplored != {}){    //unexplored 集合非空
            get pk in unexplored;   //从该集合中获取一个元素
            delete pk from unexplored;  //从unexplored 中删除pj(因为之后将发送消息)
            send M to pk;           //给pk发送消息
        }
        send <parent> to Pj
    }else
        send <reject> to pj;        //说明pj已经有父节点,因此回复reject 

upon receiving <parent> or <reject> from Pj: //收到<parent>,或<reject>消息
    if(received <parent>)       //收到<parent>消息
        then add j to children; //将j加入到孩子集合中
    if unexplored == {} then {  //判定邻居节点是否遍历完全
        if (parent != i)        //如果为非根节点,则向其父节点发送<parent>
            then send <parent> to parent;
        terminate;              //运算完毕终止
    }else {
        get pk from unexplored;     //否则继续完成对邻居节点的遍历
        delete pk from unexplored;
        send M to Pk;
    }
```

**引理2.10:** 在异步执行的每个容许执行,Alg2.3构造一颗以$P_f$为根的DFS树

**定理2.11** 对于一个具有m条边,n个节点的网络,给定特殊节点,存在一个时间复杂度以及消息复杂度均为O(m)的异步算法,使得找到一个DFS树
消息复杂度证明:每个边的每个节点最多会发送\<parent>\<reject>各一次,一条边最多4次,因此复杂度最高为$O(4m)=O(m)$


### 2.5 不指定根的DFS生成树
算法假设:各节点标识符唯一,不妨为自然数
基本思想:
>+ 节点可自发唤醒,均尝试构造一颗以自己为根的DFS生成树,当两颗DFS树尝试链接同一节点时,将该节点加入根id较大的DFS树
>+ 对于每个节点设置一个leader变量,初值为0,唤醒自己时设置leader为自己的id
>+ 当节点唤醒时,将自己id发给所有邻居
>+ 当$P_i$收到来自邻居$P_j$的标识符$y$,比较$y$(邻居的标识符)以及$leader_i$(自己的标识符),可以分成下面几种状况:
>> 1. 如果$y>leader_i$(邻居的leader比自己的大):将$leader_i$设置为$y$,将$P_j$设置为$P_i$的父亲,然后修改所有$P_i$的DFS子树中所有节点的leader
>> 2. 若$y< leader_i$(自己比邻居的leader大):不操作,因为后续操作某一id比y大的树将会更新邻居信息.
>> 3. 若$y==leader_i$,不操作,但发送\<already>,防止其停机阻塞,因为同属一个DFS树中

#### 伪代码:
```c++
//Alg构造生成树,不指定根
//Code for processor Pi,0<=i<=n-1
//变量定义:
var parent:init nil;    //指示其父节点
    leader : init 0;    //指示其根节点id
    children:init {};   //指示其孩子节点(集合)
    unexplored: init all the neighbors of Pi;   //还未发消息的邻居集合

upon receiving no message:  //自主唤醒
    if(i==r and parent==nil) then{  //初始状态,自主唤醒开始竞选
        leader:=id; parent:=i;      //开始试图构建自己的子树
        while(unexplored != {}){    //unexplored 集合非空
            get pj in unexplored;   //从该集合中获取一个元素
            delete pj from unexplored;              //从unexplored 中删除pj(因为之后将发送消息)
            send <leader> to pj;           //给pj发送消息
        }
    }

upon receiving <new-id> from neighbor pj:   //当pj收到M
    if(leader < new-id) then{               //当邻居的leader大于自己的leader
        leader = new-id; parent:=j;         //选取邻居节点为leader,并加入
        unexplored = all the neighbors of Pi except Pj //重置unexplored
        while(unexplored != {}){    //unexplored 集合非空
            get pk in unexplored;   //从该集合中获取一个元素
            delete pk from unexplored;  //从unexplored 中删除pj(因为之后将发送消息)
            send <leader> to pk;           //给pk发送消息
        }
        send <parent> to Pj;        //邻居节点遍历完之后,给父节点发送消息
    }else if (leader == new-id)     //在同一颗DFS树中
        send <ready> to pj;         //防止Pj停机阻塞
                                    //剩下的leader<new-id,直接令其停机,因此不操作

upon receiving <parent> or <already> from Pj: //收到<parent>,或<reject>消息
    if(received <parent>)       //收到<parent>消息
        then add j to children; //将j加入到孩子集合中
    if unexplored == {} then {  //判定邻居节点是否遍历完全
        if (parent != i)        //如果为非根节点,则向其父节点发送<parent>
            then send <parent> to parent;
        terminate;              //运算完毕终止
    }else {
        get pk from unexplored;     //否则继续完成对邻居节点的遍历
        delete pk from unexplored;
        send <leader> to Pk;
    }
```
#### 分析:
目前算法仅有根能显式的终止,其他节点没有终止,始终在等待msg,但通过对该算法进行修改,使用广播的方式从根节点广播终止msg即可
**正确性:** 设$P_m$为自发唤醒节点中标识符的最大者,其标识符$id_m$,那么$id_m$始终都会传播.其产生的parent与chilldren与之前指定根的设置是一致的.
**定理2.12:** 设自主唤醒的最大标识符节点为$P_m$,每次容许执行,构造一个根为$P_m$的DFS树
**定理2.13:** 在异步模型的每个容许执行中,只有一个处理器终止作为树的根

**复杂性:**
定理:对于一个具有m条边,n个节点的网络,其自发启动的节点共p个,其ID最大者的启动时间为t,则算法的消息复杂度为$O(pn^2)$,时间复杂度为O(t+m)

消息复杂度:对于p个自发唤醒的节点,每个节点均尝试构建一颗自己为节点的DFS树,当图为完全图时,其消息复杂度为$O(p*n^2)$

时间复杂度:类似之前的证明,但是还考虑到节点的唤醒时间t

### 2.6 小结
分类:
>+ 单源(centralized alg):仅有一个启动者
>+ 多源(decentralized alg):任意进程均可称为启动者
>+ 启动者(initiator):自发地执行局部算法,由一内部事务触发执行
>+ 非启动者:接受一个msg后触发其执行

复杂性:
>+ Msg复杂性:msg总数
>+ Bit复杂性:发送msg中bit的总数目

时间复杂性:
分布式算法的时间复杂性是满足下面两个假定的计算所耗费的最大时间:
>+ T1:一个进程在零时间内可计算任何有限数目的事件
>+ T2:一个msg发送和接受事件设定为至多1个时间单位

缺点:针对算法的所有计算,其结果可能是极不可能发生的计算(??)


分布式算法的one-time复杂性是满足下述假设的一个计算最大时间,同样需要满足下面两个假设:
>+ O1:同T1
>+ O2:发送和接受msg所需要的时间恰好为1个单位时间

缺点:某些计算可能被忽略,其中可能有极其耗时的计算.(??)









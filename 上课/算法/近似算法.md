# 近似算法
## 一、NP-完全性理论
### 计算机科学的局限性:
>+ 问题的可解性：问题及其可解性可用函数和可计算性来代替
>+ 可计算性理论：研究计算的一般性质的数学理论，它通过建立计算的数学模型（例如抽象计算机），精确区分哪些是可计算的，哪些是不可计算的。
>+ 可计算函数：能够在抽象计算机上编出程序计算其值的函数。这样就可以讨论哪些函数是可计算的，哪些函数是不可计算的。可计算函数对应的问题是**可计算**的。
>+ Church-Turing论题：若一函数在某个**合理**的计算模型上可计算，则它在图灵机上也是可计算的。
>+ 不可计算性：很多问题和函数是无法用具有有穷描述的过程完成计算


### 对于可计算性问题：其计算复杂性如何度量？
**多项式时间算法：** 设n是输入的size，k是某个常数，其最坏情况下的运行时间是 $O(n^k)$ 的算法。
**超多项式时间算法：** 问题可解，但并非对任意的常数k其算法的时间均是 $O(n^k)$ 。可能为指数之间或者阶乘时间
通常认为：
>+ 多项式时间可解的问题是易解的
>+ 超多项式时间可解的问题是不易解的

不可计算性问题：**无论使用何种计算机**，无论使用多少时间都无法解决的问题。例如，**图灵停机问题**

对于停机问题的一个描述为:
是否存在一个程序正确判定输入给它的任何一个程序是否会停机？
假设这样的程序存在,那么该程序无法判断自己是否会正常停机.与假设矛盾,因此证伪.

### 问题的形式化定义
**抽象问题$Q$:** 可以视为一个输入实例集合$I$到问题的解集合$S$的二元关系.
**判定问题:** 则可以表示为解集合有且仅有${0(假),1(真)}$的一类判定问题,即
$$
f: 实例集I \to 解集\{0(假),1(真)\}
$$
**优化问题转化:** 如最优的最短路可以转化为判定长度为x的最短路是否存在

### 编码
**编码:** 抽象问题需要编码为具体问题才可以被程序理解一节秋季,对于$S$(抽象对象集合)的编码可以理解为$S$到二进制串集合的映射$e$使得:
$$
e: S\to \{0,1\}^*
$$
**具体问题:** 将上述经过转化后的实例集编码的二进制串集合的问题,称为具体问题
**算法的时间复杂度:** 由具体问题定义,对于1进制来说当编码长度为$\Theta(k)$的,其时间复杂度为$O(k)$,对于二进制编码的问题,若其编码长度为$\Theta(k)$其时间复杂度可以表示为$O(2^k)$

### 形式语言框架
**字母表：** 字母表$∑$是符号的有限集
**语言 L：** 字母表$∑$上的语言L是由表中符号组成的串的任意集合， $ε$表示空串， $Φ$表示空语言
**闭包$∑^*$：** $∑$上所有串构成的语言， $∑$上每个语言均是$∑^*$的一个子集
**接受/拒绝串：** 设输入x$∈{0, 1}^*$, 若算法输出 $A(x) = 1$，则称算法A接受串x；若 $A(x) = 0$，则算法A拒绝串x。
**接受语言：** 算法A接受的串的集合，即
         $$    L = \{ x∈ \{0, 1\}* : A(x) = 1 \}$$
**算法A接受语言L：** $∀x∈L，A(x)=1$
**判定语言L:** 若算法A接受L中的每个串，拒绝每个不在L中的串，则称L是由A判定的语言
**算法A判定语言L:** $∀x ∈L , A(x)=1;  ∀x ∉ L , A(x)=0; $
**多项式时间接受的语言L:** 若存在某个常数k，对任意长度为n的串 $x∈L$, 算法A在$O(n^k)$时间内接受x， 则称L是算法A在多项式时间内接受的语言。
**多项式时间判定的语言L:** 若存在某个常数k，对任意长度为n的串 $x∈ \{0, 1 \}^*$, 算法A可在$O(n^k)$时间内正确地判定是否有$x ∈ L$， 则称L是算法A在多项式时间内可判定的语言。

### 图灵机
图灵机可以描述为一个有限状态机
对于其控制器决定执行下面三个操作任意一个
>+ 1）改变有限状态控制器中的状态；
>+ 2）读写头在相应的方格中写一符号；
>+ 3）读写头左、右移一格或不动。

**确定型图灵机DTM：** 若对任一个状态和符号，要执行的动作都是唯一的
**非确定型图灵机NTM：** 若执行的动作是有穷多个可供选择

### NP以及NPC问题
#### P类问题
一类问题的集合，对其中的任一问题，都**存在一个确定型图灵机**M和一个**多项式p**，对于该问题的**任何（编码）长度为n的实例**，M都能在**p(n)步内**，给出对该实例的回答（yes）。

**形式化定义：**
P={ L：L是一个能在多项式时间内被一台DTM所接受的语言}

**非形式定义：**
P是所有用确定性算法在多项式时间内可解的(判定)问题的集合

#### NP类问题:
一类问题的集合，对其中的任一问题，都存在一个**非确定型图灵机M**和一个**多项式p**，对于该问题的**任何（编码）长度为n**的实例，M都能在**p(n)步内**，给出对该实例的回答（yes）。

**形式化定义：** NP={ L：L是一个能在多项式时间内被一台NTM所接受的语言}
 
**非形式定义：** NP是所有用非确定性算法在多项式时间内可解的(判定)问题的集合

对于NP问题使用求解时可以分成下面两个阶段:
>+ 猜测阶段:对规模为n的输入实例x，产生一个输出y。通常是用多项式时间的非确定算法产生解y，可以通过增加1条非确定性选择语句实现之：
$$choice( S )： 任意选择集合S的1个元素。$$
对同一个实例x，下次输出的解就不一定是y。
>+ 验证阶段:检验y是否满足解的形式，是否是问题的解？验证阶段是使用多项式时间的确定性算法。

对于确定性图灵机,choice操作是随机的,但是对于非确定性图灵机该操作可以理解为并行的计算,因此每次至少有一个计算可以选择正确值所在的计算步骤

##### 相关定义
**验证算法A:** A有2个参数：x是待验证的输入串，y是称为“证书”的二进制串。算法A验证了输入串x是指：
$$若 ∀x∈L，∃证书y，使得A(x, y)=1。$$
**算法A验证的语言:**
$$L=\{ x ∈\{0,1\}^*: ∃证书y ∈{0,1}*, 满足A(x, y)=1\}$$
直观上，若对任意串x∈L，都存在一个证书y，算法A能用y来证明x∈L，则算法A就验证了语言L 。
**多项式时间验证**
若存在一个多项式时间算法A和常数c，满足：
$$L = \{ x∈\{0,1\}^* : ∃证书y，|y| = O(|x|c) 满足 A(x,y)=1 \}  $$
则称算法A在多项式时间内验证了语言L。

结合上述定义我们可以得到NP问题的另一种定义:
即NP问题可以表示为在多项式时间内可以验证的问题(即可以检验解的正确性)
其中验证可以表示为：给定一个问题的实例和证书（Certificate，证书相当于证据），验证该证书是否是问题的正确答案。

除此之外,我们还可以得到NP问题的其他等价定义:
定理:语言L可在多项式时间内被非确定性地接受，当且仅当L可在多项式时间内被确定性地验证
非形式地：多式时间内可验证的问题即为NP问题
NP= {NDTM能在多项式时间内接受的语言类},NDTM即非确定性图灵机
NP= {DTM能在多项式时间内验证的语言类},DTM即确定性图灵机

#### 规约:
##### 多一规约
假设L1和L2是两个判定问题，f将L1的每个实例I变换成L2的实例f(I)。若对L1的每个实例I，I的答案为“yes”当且仅当f(I)是L2的答案为“yes”的实例，即：
$$ ∀I，I是L1输出“yes“的实例 ⇔ f(I)是L2输出”yes“的实例$$
则称f是从L1到L2的多一归约，记作： $L1≤_mL2$（传递关系）
**直观理解:该传递关系可以理解为求解L1问题不会难于L2,即L2至少与L1一样难**

##### 多项式时间多一归约 
若f是多项式时间可计算，则上述归约称为多项式时间多一归约，也称多项式时间变换。记作：
$$
L1≤_m^pL2
$$
但是通常情况下,在不做额外说明的情况下,仅考虑多项式时间内规约,因此有时不显式标记多项式时间规约

#### NPC/NP-Hard 问题
**NPC问题定义:**
对于一个(判定性)问题q，若
>+ (1) q∈NP
>+ (2) NP中任一问题均可多项式时间多一归约到q

则称问题q为NP-完全的(NP-complete，NPC)

**HP-Hard 定义:**
若问题q仅满足条件(2)而不一定满足条件(1)，则问题q称为NP-难的(NP-hard，NPH)。
显然：$NPC⊆NP-hard$

### 三种规约策略
#### 1. 等价规约
证明两问题可以互相规约,即对于问题X,Y
$$
X\leq_m Y,Y\leq_m X\\
则 X\equiv_m Y
$$
经典问题:最大独立集问题  $≡_p$ 最小顶点覆盖

#### 2. 从特殊到一般
如证明顶点覆盖可以规约到集合覆盖,即:
$$
Vertex—Cover \leq_m Set-Cover
$$

#### 3. 通过编码
通过编码映射的方式来将问题转化为新的问题,如3-SAT问题可以通过编码将其映射到一个独立集问题

## 二.近似算法
现实中许多优化问题是**NP-hard**的,由复杂性理论知：若$P≠NP$(很可能为真)，就不可能找到多项式时间的算法来对问题的所有输入实例求出最优解。但若放松要求，就可能存在有效求解算法。实用中可考虑3种放宽要求的可能性：
>+ 超多项式时间启发:不再要求多项式时间算法，有时求解问题存在超多项式时间算法，实用中相当快。例如，0/1背包问题是NPC问题，但存在1个伪多项式时间算法很容易解决它.
缺点：该技术**只对少数问题有效**（弱NPC问题）。
>+ 启发式概率分析:不再要求问题的解满足所有的输入实例。在某些应用中，有可能输入实例的类被严格限制，对这些**受限实例**易于找到其有效算法。而这种结果往往归功于对输入实例约束的**概率模型**。
缺点：选取一个特殊的**输入分布**往往是不易的
>+ 近似算法:**不再要求总是找到最优解**。在实际应用中有时很难确定一个最优解和近似最优解(次优解)之间的差别，因问题的输入实例数据本身就可能是**近似**的。
设计一个算法能够求出所有情况下的次优解来解NP-hard问题往往是**真正有效**的手段。

根据难易程度我们可以将优化问题按照下面的方式进行分类:
>+ 容易近似
       Knapsack，Scheduling，Bin Packing等
>+ 中等难度
       Vertex Cover，Euclidean TSP，Steiner Trees等
>+ 难于近似
       Graph Coloring，TSP，Clique等

### 预备知识以及基本定义
#### 优化问题的相关定义
对于优化问题$\prod$由三部分构成:
>+ 实例集D：输入实例的集合
>+ 解集S(I)：输入实例$I\in D$的所有可行解的集合
>+ 解的值函数f：给每个解赋一个值，$f：S(I)→R$

对于最大值优化问题的最优解$\sigma_{opt}$需要满足下面条件:
对于给定$I\in D$ 使得:
$$
\forall \sigma \in S(I),f(\sigma_{opt})\geq f(\sigma)
$$
此时我们将$f(\sigma_{opt})$记为最优解的值即$OPT(I)=f(\sigma_{opt})$,有时将$\sigma_{opt}$称为最优解

#### 约定:
>+ 1）f的值域和I里的所有数是整数,易于扩展至有理数
>+ 2）对任何σ ∈S(I)，f(σ)受囿于多项式(对I中数的size),**只讨论NP完全的优化问题**，因为它**易被转换为判定问题**

对于近似算法A,是一个**多项式时间**求解优化问题$Π$的算法，使得对一个给定的$Π$的输入实例I，它输出某个解$σ∊S(I)$。通常，我们用$A(I)$表示算法A所获得的解的值$f(σ)$。（有时不太严格地也可表示其解）

#### 近似算法的性能
**性能保证:** 在最优解和近似解之间建立某种关系,这种度量称为性能保证
**绝对性能度量:** 对于一个优化问题,能找到某个常数k,使得其近似算法A得到的结果$A(I)$,与实际最优解的值满足下面关系:
$$
\forall I \in D, |A(I)-OPT(I)|\leq k
$$
但是实际上对于大多数NP-Hard问题,只有当$P=NP$才能找到绝对近似算法

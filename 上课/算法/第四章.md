## 第四章 分布式系统中的计算模型
本章内容:
>+ 分布式系统计算模型的复杂性
>>+ 系统由并发执行部件构成
>>+ 系统中无全局时钟
>>+ 必须捕捉系统部件可能的失效
>+ 对策
>>+ 因果关系（Causality）重点
>>+ 一致状态（Consistent states）
>>+ 全局状态

### 4.1 基础知识
协议(Prorocol)
#### 协议中的控制语句
1.Send（destination, action; parameters）
>+ destination：处理器抽象。实用中是通信实体的地址：机器名，机器的端口号(即1个socket地址)
>+ action控制msg，希望接收者采取的动作
>+ parameters：参数集合

假定：
>+ msg发送是**无阻塞、可靠的**（语义类似于TCP套接字）； 
>+ 有时假定较弱的msg传递层（等价于UDP）。


2.接收msg
接收msg可推广至接收事件，引起事件的原因是：外部msg、超时设定、内部中断
事件在处理前，一般是在缓冲区(如事件队列)中，若一处理器想处理事件，它必须执行一个声明处理这些事件的线程。例如:
```c++
waiting for A1, A2,..., An ：//声明
      A1（Source; parameters）
           Code to handle  A1
      …
      An（Source; parameters）
           Code to handle  An 
```
表示收到A1,A2,...msg时执行对应操作

3.超时
当怀疑远程处理器失效时，可通过超时检测来判定,例如:
```c++
当T秒后仍未收到P的类型为event的msg时，执行指定的动作 
   waiting until P sends (event; parameters), timeout=T
      on timeout
               timeout action

```

### 4.2 因果关系
分布式系统缺乏全局的系统状态原因:
>+ 1.非即时通信:系统的全局状态依赖于观察点,产生原因可能有:
>> 1.传播延迟 
>> 2.网络资源的竞争
>> 3.丢失msg重发
>+ 2.相对性影响:计算机的实际时钟存在漂移，时钟同步仍然是一个问题。因此使用时间来同步不是一个可靠机制
>+ 3.中断:CPU竞争、中断、页错误等,因此不可能在同一时刻观察一个分布式系统的全局状态必须找到某种可以依赖的性质：
>>+ 时间回溯
>>+ 因果相关

#### 假设:
$P＝{P1, P2,.., Pn}$：处理器集合
$E$：全体事件的集合
$E_p⊆E$, $E_p$表示发生在p上的所有事件
$e_1< e_2$:事件e1发生e2在之前（亦记：e1→e2）
$e_1<_I e_2$：事件e1发生e2在之前，I为信息源
发生在同一节点p上的事件满足全序：若e1,e2 ∈ Ep，则 $e_1<_pe_2$ 或 $e_2<_pe_1$ 成立
e1发送消息m,e2接收m，则$e_1<_me_2$

**Happens-before关系（$<_H$）**
该关系为传递闭包,满足下面关系:
>+ 规则1：若$e_1<_pe_2$，则$e_1<_He_2$
>+ 规则2：若$e_1<_me_2$，则$e_1<_He_2$ 
>+ 规则3：若$e_1<_He_2$，且$e_2<_He_3$，则$e_1<_He_3$ (传递)

Note:$<_H$是一种偏序关系,当两时间不能由$<_H$定序时,称这两事件并发


**H-DAG**
有时将Happens-before关系描述为一个有向无环图
顶点集VH是事件集E：$e∈V_H$ 当且仅当 e∈E 
边集EH：若(e1，e2)∈EH 当且仅当$e_1<_Pe_2或e_1<_me_2$

定理:通过H关系确定的偏序关系可以来建立一个与全序关系一致的

#### 4.2.1 Lamport时间戳
基础思想:
>+ 每个事件e有一个附加的时戳：e.TS
>+ 每个节点有一个局部时戳：my_TS
>+ 每个msg有一个附加时间戳：m.TS
>+ 节点执行一个事件时，将自己的时戳赋给该事件；
>+ 节点发送msg时，将自己的时戳赋给所有发送的msg


实现:
```c++
Initially：my_TS=0;
On event e：
   if  ( e是接收消息m ) then
            my_TS = max ( m.TS, my_TS );
            //取msg时戳和节点时戳的较大者作为新时戳
   my_TS++;
   e.TS＝my_TS; //给事件e打时戳
   if ( e是发送消息m ) then
            m.TS＝my_TS; //给消息m打时戳
```

算法简述:用时间戳来表示时间/消息时间,在消息传递的过程中不断更新对应时间戳保证算法正确性

Lamport算法是因果相关的,但为了避免相同时间戳(并发事件),因此可以在时间戳后面添加小数来确定先后次序

算法特点:分布、容错、系统开销小

缺点:
>+ 由于并发事件次序任意,因此不能通过时间戳判定时间是否因果相关
>+ 无法实现任务迁移

#### 4.2.2 向量时间戳
使用一个向量来表示时间戳,向量长度为处理器个数,对于事件e的向量时戳$e.VT[i]$表示在处理器i上需要有$e.VT[i]$个事件发生后事件e才能发生.
**向量时戳的比较:**
$e1.VT\leq e2.VT$当且仅当对于$e1.VT[i]$每一位均小于$e2.VT[i]$
$e1.VT < e2.VT$当且仅当满足上述条件的同时,要求$e1.VT!=e2.VT$

**向量时戳算法**
对于每个节点,有一个局部时戳$my_VT$
对于每个事件,有一个向量时戳$e.VT$
对于每个msg,有一个向量时戳$m.VT$

当节点执行事件时,将自己的时戳赋给该事件(对应位更新)
当节点发送msg时,将自己时戳赋给所有发送的msg()
节点接受msg时,自己向量每一位更新为自己与msg较大者

**伪代码**
```c++
Initially：my_VT=[0,…,0];
On event e：
   if  ( e是消息m的接收者 ) then
         for i=1 to M do //向量时戳的每个分量只增不减
               my_VT[ i ] = max( m.VT[i], my_VT[i] );
   my_VT[ self ]++; //设变量self是本节点的名字
   e.VT＝my_VT; //给事件e打时戳
   if ( e是消息m的发送者 ) then
            m.VT＝my_VT; //给消息m打时戳

```

**性质**
若事件a与事件b不可比较,则两事件并发
若可比较,则两事件满足因果相关,有前驱关系

**因果序检测**
检测处理器接收到消息时,局部时戳与接受消息时戳,如果消息时戳小雨局部时戳,则存在矛盾

**因果通信**
由于处理器不能决定msg到达次序,因此对于过早到达的msg可以采用延迟处理的方式来调整传递顺序

**FIFO通信**
源处理器给每个发送的msg编号,当处理器收到大编号时,选择deliver,直到小编号消息均到达

**实现因果通信**
思想:抑制P发送信息m,直至可断定无其他处理器上的消息是的消息的时戳小于局部时戳
对于每个节点,额外存储eariest[1...m]表示当前能过传递消息时戳的下界,blocked[1...m]表示阻塞队列数组,earliest初始化为全1,阻塞队列置空

**伪代码**
```c++
3:On the receipt of msg m from node p:
4:     delivery_list={};
5:     if （blocked[p]为空）then
6:           earliest[p]=m.timestamp;
7:    将m加到blocked[p]队尾；//处理收到的消息
8:    while（∃k使blocked[k]非空 and 对每个i=1,…,M(除k和self外),
                not_earliest( earliest[i], earliest[k], i )）{//处理阻塞队列
         //对非空队列k，若其他节点i上无比节点k更早的msg要达到本
         //地，则队列k的队首可解除阻塞
9:             将blocked[k]队头元素m’出队，且加入到delivery_list;
10:           if （blocked[k]非空）then
11:                       将earliest[k]置为m’.timestamp；
12:           else       increment earliest[k] by 1k     }//end while
13:   deliver the msgs in delivery_list; //按因果序
```

**算法简述:**
对于可能发生冲突的信息,循环检测是否存在阻塞,如果无阻塞则执行,并更新earliest,否则循环等待

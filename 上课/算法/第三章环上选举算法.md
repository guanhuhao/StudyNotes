# 环上选举算法
## 基础概念介绍
**本章主要内容:**
>+ Leader选举问题
>+ 匿名环
>+ 异步环
>+ 同步环

**问题定义:**
在一组处理器中选取一个特殊节点作为leader

**用途:**
>+ 简化处理器之间的协作；
>+ 有助于达到容错和节省资源。
>+ 例如，有了一个leader，就易于实现广播算法
>+ 代表了一类破对称问题。例如，当死锁是由于处理器相互环形等待形成时，可使用选举算法，找到一个leader并使之从环上删去，即可打破死锁。

## 3.1 leader选举问题
### 问题定义:
问题从具有**同一状态**的进程配置开始，最终达到一种配置状态。每个处理器最终确定自己是否是一个leader，但只有一个处理器确定自己是leader，而其他处理器确定自己是non-leader。
> 1. 要求各节点从同一状态开始
> 2. 处理器必须确认自己为leader或者non-leader
> 3. 有且仅有一个leader

### 算法作用:
如果要执行一个分布式算法，且没有一个优先的优选人做为算法的初始进程，就要进行进程选举。(例如指定根的DFS树的生成问题),选取算法的初始进程.

### 选举算法的定义:
>+ 每个处理器具有**相同的局部算法**；
>+ 算法是**分布式的**，处理器的任意非空子集都能开始一次计算；
>+ 每次计算中，算法达到终止配置。在每一可达的终止配置中，**只有一个**处理器处于领导人状态，**其余均处于失败状态**。

**一个算法解决了leader选举问题需满足(必要不充分条件)：**
>+ 终止状态被划分为两类：选中和未选中状态。一旦一个处理器进入选中(或未选中)状态，则该处理器上的转换函数将只会将其变为相同的状态；
>+ 在每个容许执行里，只有一个处理器进入选中状态，其余处理器进入非选中(non-selected)状态。


### 环的形式化模型:
对每个$i，0≤i ≤n-1$，
$P_i$到$P_{i+1}$的边标号为1，称为左(顺时针)
$P_i$到$P_{i-1}$的边标号为2，称为右(逆时针)
这里的标号加减**均是mod n**的

### 研究环网络的原因:
环网络之所以吸引了如此多的研究，是因为它们的行为**易于描述**；且从环网络推导出的下界，可应用于**具有任意拓扑结构**的网络算法设计,可以视为若干环网络的叠加

## 3.2 匿名环
### 基础设定介绍
**匿名算法：** 若环中处理器**没有唯一的标识符**，则环选举算法是匿名的。更形式化的描述：每个处理器在系统中**具有相同的状态机**，在这种算法里，msg接收者只能根据**信道标号来区别。**
**（一致性的）uniform算法：** 若算法**不知道处理器数目**，则算法称之为uniform，因为该算法对每个n值看上去是相同的。每个节点拥有一套相同的状态机.
**non-uniform算法：** 算法已**知处理器数目n**
**形式化描述：** 在一个匿名、一致性的算法中，所有处理器只有一个状态机；在一个匿名、非一致性的算法中，对每个n值（处理器数目）都有单个状态机，但对不同规模有不同状态机，也就是说n可以在代码中显式表达。

### 对于环系统,不存在匿名的选举算法
证明分四步:
$$
\begin{cases}
1.证明环中不存在匿名的非一致性算法(n已知)\\
2.证明环中不存在匿名的一致性选举算法(n未知)\\
3.证明同步环系统中不存在匿名的选举算法\\
4.证明异步环系统中不存在匿名的选举算法
\end{cases}
$$

#### 同步算法的不可能性:
**同步系统的性质:** 在同步系统中，一个算法**以轮的形式进行**。每轮里所有待发送msg被传递，随后每个处理器进行一步计算。一个处理器的初始状态包括在outbuf里的任何msg。这些消息在第一轮里被传递到某处理器的左和右邻居

**不可能性证明：**
>+ 在一个匿名环中，处理器间始终保持对称，若无某种初始的非对称(如，标识符唯一)，则不可能打破对称。在匿名环算法里，所有处理器开始于相同状态。
>+ 因为他们执行同样的程序(即他们的状态机相同)，在每轮里各处理器均发送同样的msg，所以在每一轮里各处理器均接收同样的msg，改变状态亦相同。

因此，**若选中一个处理器，则其他所有处理器亦被选中(同时宣布自己为leader)**。因此，不可能有一个算法在环中选中单个处理器为leader。

**具体证明步骤:**
>+ 假设:R是大小为n>1的环（非均匀），A是其上的一个匿名算法，它选中某处理器为leader。因为环是同步的且只有一种初始配置，故在R上A只有唯一的合法执行。
>+ 引理:在环R上算法A的容许执行里，对于每一轮k，所有处理器的状态在第k轮结束时是相同的。**对于环上的匿名同步算法,每一轮结束后所有处理器状态相同!**
>+ 使用归纳法证明:K=0(第一轮之前)，因为处理器在开始时都处在相同的初始状态，故结论是显然的。
设引理对k-1轮成立。因为在该轮里各处理器处在相同状态，他们都发送相同的消息mr到右边，同样的消息ml到左边，所以在第k轮里，每处理器均接收右边的ml ，左边的mr 。因此，所有处理器在第k轮里接收同样的消息，又因为它们均执行同样的程序，故第k轮它们均处于同样的状态。
>+ 上述引理蕴含着：若在某轮结束时，一个处理器宣布自己是leader(进入选中状态)，则其它处理器亦同样如此，这和A是一个leader选举算法的假定矛盾！因此证明：
对于同步环上的leader选举，不存在非均匀的匿名算法。

## 3.3 异步环
### 假定:
>+ 当一个状态机(局部程序)和处理器Pi联系在一起时，其状态成分变量$id_i$被初始化$P_i$的标识符的值，故**各处理器的状态是有区别**的。
>+ 通过指派一个处理器列表按顺时针(从最小标识符起)指定环。注意是通过$id$排列，不是通过$P_i$的下标i来排列(0≤i≤n-1)，**假定$id_i$是$P_i$的标识符**。（因为下**标i通常是不可获得**的）
>+ 均匀算法:每个标识符id，均有一个唯一的状态机，但**与环大小n无关**。而在匿名算法中，均匀则指所有处理器只有同一个状态。
>+ 非均匀算法:**每个n和每个id均对应一个状态机**，而在匿名非均匀算法中，每个n值对应一个状态机。

### 3.3.1 LCR算法 $O(n^2)$
#### 基本思想
>+ 每个处理器Pi发送一个msg(自己的标识符)到左邻居，然后等其右邻居的msg
>+ 当它接收一个msg时，检验收到的idj，若idj>idi，则Pi转发idj给左邻，否则没收idj(不转发)。
>+ 若某处理器收到一个含有自己标识符的msg，则它宣布自己是leader，并发送一个终止msg给左邻，然后终止。
>+ 当一处理器收到一个终止msg时，向左邻转发此消息，然后作为non-leader终止。

#### 代码:
```c++
// init var: asleep←true, id ←I         //初始化
Begin
 While (receiving no message) do        //启动
  (1) if asleep do  
      (1.1) asleep←false
      (1.2) send <id> to left-negihbor  //发送节点id给左邻居
    end if
 End while

 While (receiving <i> from right-neighbor) do   //收到右邻居信息
  (1) if id < <i> then :                        //收到序号大的消息,进行传递
       send <i> to left-neighbor  
       end if
  (2) if id = <i> then :                        //收到自己环绕一周的消息
      (2.1) send <Leader,i> to left-neighbor    //向邻居宣布自己为leader
      (2.2) terminates as Leader                //以自己为leader进入终止状态
    end if
 End while

 While (receiving <Leader,j> from right-neighbor) do //收到leader已经产生消息
  (1) send <Leader,j> to left-neighbor               //传递该消息
  (2) terminates as non-Leader                       //以非leader节点终止
 End while
end

```
#### 分析:
>+ 正确性:在任意容许执行中仅有id最大的节点信息不会被没收,因此仅有id最大额宣布自己为leader.
>+ msg复杂度:消息复杂度为$O(n^2)$,构造id按照id值排序绕成环,则第i个节点发送i次消息

### 3.3.2 k邻居算法 $O(nlogn)$
#### 基本思想:
>算法**按阶段执行**，在第l阶段一个处理器试图**成为其$2^l$-邻接的临时leader**。只有那些在**l-th阶段成为临时领袖的处理器才能继续进行到(l+1)th阶段**。因此，l越大，剩下的处理器越少。直至最后一个阶段，整个环上只有一个处理器被选为leader。
#### 具体实现:
>+ phase0: 每个结点**发送1个probe消息**(其中包括自己的id)给两个1-邻居，若接收此msg的邻居的id大于消息中的id，则没收此msg；否则接收者**发回一个reply msg**。若一个结点从它的**两个邻居收到回答msg reply**，则该结点成为phase0里它的1-邻居的临时leader，此结点可继续进行phase1。
PS:选举大小为3的领域中较大者,最多共n/2个leader
>+ phase l：**在l-1阶段中成为临时leader的处理器**Pi发送带有自己id的probe消息至它的2l邻居。若此msg中的id小于左右两个方向上的2*2l个处理器中任一处理器的id，则此msg被没收。若probe消息到达最后一个邻居而未被没收，则最后一个处理器**发送reply消息给Pi**，若Pi从**两个方向均接收到reply消息**，则它称为该阶段中2l邻居的临时leader，继续进入下一阶段。
PS:选举大小为$1+2*2^l$邻域节点中较大者,最多有$\frac{n}{1+2^{l}}$个这样的节点
>+ 终止:当$1+2^l>=n$接收到自己的probe消息的结点终止算法而**成为leader**，并**发送一个终止msg到环上。**

##### probe msg信息的转发和应答:
probe消息中有三个域：<prob, id, l, hop>
>+ id:标识符
>+ l:阶段数
>+ hop:跳步计数器初值为0，结点转发probe消息时加1.

#### 代码:
```c++
// var asleep init true;    //初始化
   upon receiving no msg:   //初始状态还没唤醒
      if  asleep then{
		asleep:=false;      //每个结点唤醒后不再进入此代码
          send<probe, id, 0, 0> to left and right;  //开始第1轮
      }
    
   upon receiving <probe, j, l, d> from left (resp, right): //收到邻居发来的探针消息
      if(j=id) then //收到自己id终止，省略发终止msg
            terminate as the leader; 
      if(j>id) and (d<2^l) then   //向前转发probe msg
            send <probe, j, l, d+1> to right (resp, left)
      if(j>id) and (d≥2l)then//到达最后一个邻居仍未没收
	     send <reply, j, l > to  left(resp, right) // 回答
      //若j<id, 则没收probe消息

   upon receiving <reply ,j , l> from left (resp, right):
      if j≠id then 
            send<reply, j, l> to right (resp, left); //转发reply
      else if already received <reply, j, l> from right (resp, left) //j=id时，Pi已收到一个方向的回答msg 
            then send <probe, id, l+1, 0> to  left and right; //也收到另一方向发回的reply
            //Pi是phase l的临时leader，继续下一阶段
```

#### 分析:
**正确性:** 
在任意容许执行中仅有id最大的节点信息不会被没收,因此仅有id最大额宣布自己为leader.

**msg复杂性:**
>+ 在第l轮中一个处理器启动的msg数量至多为$4*2^l$(邻域为$2*2^l$,过去回来因此仔乘2)
>+ 每轮最多有$\frac{n}{1+2^{l}}$进行参加选举,因为$2^l+1<=n$以你我们有$l<=logn$
$$
4n+n+\sum_{l=1}^{log(l)}4*2^l*\frac{n}{1+2^{l}}<=8nlogn
$$

### 3.3.3 下界$\Omega(nlogn)$
我们针对leader选举算法的一个变种:
>+ 选中的leader必定是环上具有最大id的处理器。
>+ 所有处理器必须知道被选中leader的id，即每处理器终止前，将选中leader的id写入一个特殊变量。

#### 基本思想:
>+ 设A是一个能解上述leader选举变种问题的均匀算法(n未知)，证明存在A的一个允许执行，其中发送了Ω(nlgn)个msgs，证明**采用构造法**。
>+ 对于大小为n/2的环构造算法的一个耗费执行(指msg的耗费)，然后将两个大小为n/2的不同环粘贴在一起形成一个大小为n的环，将两个较小环上的耗费执行组合在一起，并迫使θ(n)个附加msg被接收。
>+ 调度：前面定义过调度是执行中的事件序列，下面给出**能够被粘贴在一起的调度**。
>+ 开调度:设σ是一个特定环上算法A的一个调度，若该环中存在一条边e使得在σ中，边e的任意方向上均无msg传递，则σ称为是open，e是σ的一条开边。
Note：开调度**未必是容许的调度**，即它可能是有限的事件序列，环上的处理器不一定是终止的。
>+ 引理3.5:对于每个n以及每个标识符集合(大小为n)存在一个由这些标识符组成的环，该环有一个A的开调度，其中至少接收M(n)个消息，这里：
$$
\begin{cases}
M(2)=1&n=2\\
M(n)=2M(\frac{n}{2}+\frac{1}{2}(\frac{n}{2}-1))& n>2
\end{cases}
$$


### 3.4 同步环
#### 简要介绍
**上下界**
>+ 上界： 提出两个msg复杂性为O(n)的算法，显然，这样的算法的msg复杂性是最优的。但运行时间并非只与环大小n有关，还与算法使用的非普通的id相关。(与id值相关)
>+ 下界： 讨论
	1）只基于标识符之间比较的算法
	2）时间受限（即若干轮内终止，轮数只依赖于环大小,不依赖于id值）的算法
	当算法受限于上述两个条件时，至少需要Ω(nlgn)个msgs.

**同步性质**
>+ 1) msg延迟是确定的，故同步模型是否有较好的结果呢?
>+ 2) 获取info不仅来自于接收msg,在某轮里的内附件也能获取info

**均匀性定义**
本节提出两个算法，msg复杂性上界为O(n),针对单向环，但是用于双向环
>1) 非均匀的：要求环中所有的结点开始于同一轮，标准的同步模型 (需知道n)
>2) 均匀的： 结点可开始于不同轮，弱同步模型 (无需知道n)
PS:判定所有节点是否在第一轮执行

#### 非均匀算法
##### 基本特征:
**选择环中最小id**（各id互不相同）的结点作为leader，按Phase运行，**每个阶段由n个轮组成**。在Phase i (i ≥ 0)，若存在一个id为i的结点，则该结点为leader，并终止算法，因此，最小id的结点被选为leader.
显然，**Phase数目取决于n个节点的标志符的取值**。
##### 具体实现:
Phase i包括轮：n·i+1, n·i+2, …, n·i+n
在第i阶段开始，若一个结点的id是i，且它尚未终止，则该节点绕环发送一个msg后作为一个leader终止；若一结点的id不是i，且它收到一个msg，则它转发此msg后作为non-leader终止
##### 分析:
>+ 正确性:id互不相同,从小到大枚举,因此leader唯一且确定
>+ Msg复杂度: 所有msg均在找到leader的阶段进行发送,每个节点均仅进行一次消息传播因此消息复杂度为$O(n)$
>+ 时间复杂度:执行的总轮数为$n*(id_{min}+1)$,**执行时间与环大小以及标识符最小值相关**
>+ 缺点:需要知道环大小n,以及同步开始(所有节点一开始均唤醒)

#### 均匀算法
##### 特点:
>+ ①无须知道环大小
>+ ②弱同步模型:一个处理器可以在任意轮里**自发地唤醒**自己，也可以是收到另一个处理器的**msg后被唤醒**

##### 基本思想:
>+ 源于不同节点的msg以不同的速度转发
>> 源于id为i的节点的msg，在每一个接收该msg的节点沿顺时针转发到下一个处理器之前，被延迟$2^i-1$轮,如源于节点2的msg,只会在第3,6,9,...轮发送消息
>+ 为克服**非同时启动**，须加一个基本的**唤醒阶段**，其中每个自发唤醒的结点绕环发送一个唤醒msg，该msg**转发时无延迟**
>+ 若一个结点在算法启动前收到一个唤醒msg，则该结点不参与算法，只是扮演一个relay(转发)角色：即转发或没收msg(**放弃选举**)

**要点:**
在基本阶段之后，选举leader是在参与结点集中进行的，即**只有自发唤醒的结点才有可能当选为leader**。

##### 具体实现:
>+ 唤醒:由一个结点发出的唤醒msg包含该结点的id，该**msg以每轮一边的正常速率周游**，那些**接收到唤醒msg之前未启动的结点均被删除**(不参与选举)
>+ 延迟：当来自一个id为i的节点的msg到达一个醒着的节点时，该msg**以$2^i$速率周游**，即每个收到该msg的节点将其**延迟$2^i-1$轮**后再转发。
>>+ Note： 一个msg到达一个醒着的节点之后，它要到达的所有节点均是醒着的。一个msg在被一个醒着的节点接收之前是处在1st阶段 (唤醒msg，非延迟) ，在到达一个醒着的节点之后，它就处于2nd阶段，并以2i速率转发(非唤醒msg，延迟)
>+ 没收规则
>>+ a) 一个**参与**的节点收到一个msg时，若该msg里的id大于当前已看到的最小(**包括自己**)的id，则没收该msg；
>>+ b) 一个**转发**的节点收到一个msg时，若该msg里的id大于当前已看到的最小(**不包括自己**)的id，则没收该msg。

#### 算法实现:
```c++
//算法  Alg3.2 同步leader选举
var waiting : init  Φ;
    asleep  : init true;    //加上relay更好 ？    : init false;
1: 设R是计算事件中接收msg的集合
2: s:= Φ;// the msg to be sent
3: if asleep then {
4:     asleep:=false;
5:     if R = Φ then { // pi未收到过msg，属于自发唤醒
6:	         min:=id;   //参与选举
7:          s:=s+{<id>}; // 准备发送
	   }else{ //已收到过msg，但此前未启动，被唤醒故Pi不参与
8: 	        min:=∞; //选举，置min为∞ ，使其变为relay结点
             // relay:=true; ？
        }
    }
9:   for each <m> in R do {// 处理完收到的m后相当于从R中删去
10:     if m < min then { // 收到的id较小时通过
11:          become not elected;  // Pi未被选中
                //可用relay控制使转发节点不延迟？
12:          将<m>加入waiting且记住m何时加入; //m加入延迟转发
13:          min:=m;
           } // if m > min then it is swallowed
14:      if m=id then become elected; // Pi被选中
        } //endfor
15:  for each <m> in waiting do
16:       if <m> 是在2m-1轮之前接收的 then
17:           将<m>从waiting中删去并加入S
18:   send S to left;          

```
#### 分析:
##### 正确性:
对∀i∈[0,n-1]，设$id_i$是结点pi的标识符，$<id_i>$是源于$p_i$的msg
引理3.9:在参与的节点中，只有最小id的节点才能收回自己的id
证明:
>+ 1.选中:最小的节点的msg不会被没收,必将回收自己的id
>+ 2.唯一:除了最小的节点,其他节点的信息都会被最小的节点没收

##### msg复杂性
消息分为三种:
>+ 第一类：第一阶段的msg(唤醒msg)
>+ 第二类：最终leader的msg进入自己的第二阶段之前发送的第二阶段msg(其它结点发出的)
>+ 第三类：最终leader的msg进入自己的第二阶段之后发送的第二阶段msg(包括leader发出的)
>+ Note：一个msg发送时，一开始是作为唤醒msg(非延迟)，当它到达的结点已唤醒时，msg就变为非唤醒msg(第二阶段，延迟msg)

**第一类消息总数:** 至多为n,因为每个节点在第一阶段至多转发一个msg
**第二类消息总数:** 至多为n,每边至多发送一个第一阶段的msg,在第r+n之后无第一阶段的msg被发送
**第三类msg总数:** 至多为2n,$n+\frac{1}{2}+\frac{1}{4}+...=2n$

##### 时间复杂度
由引理3.13知，当leader接收到自己的id时，计算终止。这发生在第一个启动算法的节点之后的$O(n· 2^i)$轮，其中i是leader的标识符。 // 当i=0时，为O(n)轮
**PS:运行时间与环大小及标识符取值相关**

#### 3.4.2 有限制算法的下界
上述算法存在下面缺陷:
>+ 它们用一种非同寻常的方式使用id，即**id决定msg延迟**多长；
>+	在每个容许的执行中，**执行轮数依赖于id**，而id相对于n而言可能是巨大的。(更主要的)

补充:
>+ 这些性质对于基于消息的有效算法而言是固有的；
>+	若一个算法中的标识符**仅用于比较**，则它**需要Ω(nlgn)个msgs**；
>+	若一个算法中，限制轮数的上界，但**独立于id**，则它的msg复杂度亦为Ω(nlgn)。
>+ 同步的下界不可能从异步的下界导出(因为需要使用同步模型的附加假定)
>+ 同步的下界对于非均匀和均匀算法均成立，但异步的下界只对均匀算法成立(?)
>+ 但是从同步导出的异步结果是正确的，并且提供了一个非均匀算法的异步下界

##### 基于比较的算法
**假设:** 假定所有处理器在同一轮开始执行(需要msg最多)
**匹配:** 环R1上的结点pi和R2上的pj在各自的环里具有相同的位置,即离id最小节点的距离相同
**序相同(等价):** 两个环x0, x1,…, xn-1和y0, y1,…,yn-1是(次)序等价的，若对每个i和j，xi< xj, 当且仅当yi< yj。(环同构),另序等价可以拓展到k-邻居
**节点在第k轮行为相似:** 对于两个执行$\alpha_1,\alpha_2$以及两个处理器$p_i,p_j$.若下述条件成立则称节点在第k轮行为相似:
>+ pi在α1的第k轮里发送一个msg到其左(右)邻居当且仅当pj在α2的第k轮里发送一个msg到其左(右)邻居；
>+ pi在α1的第k轮里作为一个leader终止当且仅当pj在α2的第k轮里作为一个leader终止。

**节点行为相似:** 所有k>0两节点均行为相似
**算法行为相似:** 每对匹配节点行为相似

**基于比较的算法定义:** 若一个算法在两个**相对次序相同**的环上**具有相同的行为**(与id无关)，则该算法是基于比较的

##### 基于比较算法的下界
**无用轮:** 对于所有序等价的某个环上均没有msg产生,那么该轮是无用的,于此相反的我们定义该轮为**主动轮**
**基于比较算法行为相似:** 对于序等价环R1,R2,若某轮在exec(R1)中是主动的,当且仅当在exec(R2)中也是主动地
**k-邻居性质:** 在k轮中由于消息仅能在k-邻居上传播,因此一个节点在k轮后的状态仅取决于其k-邻居
**转换序列相同:** 若R1,R2次序相同,那么在exec(R1)第1至第k轮里经历的转换序列与exec(R2)在1到k轮转换序列相同,该引理蕴含:在k个主动轮结束时，Pi和Pj的状态相同,可使用归纳法进行证明
**有空隙环:** 对于两个id,如a,b,若a+1,a+2,...b-1均不在环上,则称该环是有空隙的(环不是一个排列)
**有空隙环上的行为相似**设R为有空隙的环,$P_i,P_j$为序等价k-邻居,则在第1至第k轮其具有相似的行为,证明方法:构造一个$R'$与$R$序等价使得在$R'$中的$P_j$与$R$中的$P_i$匹配
**2进制的逆序环:** 由i的二进制表示的逆序列构成的环,该环具有按照2的幂次进行划分都是序等价的

**引理3.19:** 对所有k< n/8以及每个Sn的k-邻居集N，在Sn中与N序等价的k-邻居集的个数(包括N本身)大于$\frac{n}{2*(2k+1)}$
我们构造下面这样一个划分使得$2^i<2k+1<2^{i+1}$

**引理3.20:** 在exec(Sn)里主动轮数目至少为$\frac{8}{n}$,证明思路假设小于8/n则推出至少存在一个节点与该节点行为相似,使得同时可能存在两个leader.


##### 时间受限算法的下界:
定义:算法的时间**不依赖于id，仅受限于环大小n**，即使id可能是无界的
>Def3.4:若对任意的n，当标识符取自于自然数集合时，在所有大小为n的环上同步算法A的最坏时间是有界的，则称A为时间有界(或时间受限time-bounded)

为了证明时间受限算法的下界,我们将其映射到一个基于比较的算法,因此我们定义下面的映射关系:

>Def3.5 设R1和R2是任意两个大小为n的序等价的环，若每对匹配的结点在exec(R1)和exec(R2)的第1至t轮里有相似的行为，则同步算法A对于环大小为n的标识符集合S是**基于t-比较**的




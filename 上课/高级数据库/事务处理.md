# 事务处理(Transaction Processing)
## 数据库保护
定义:**排除**和**防止**各种对数据库的干扰破坏，确保数据安全可靠，以及在数据库遭到破坏后尽快地**恢复**

通过下面的方式来实现保护:
>+ 数据库的恢复技术(Deal with failure),本章重点
>+ 并发控制技术(Deal with data sharing),在18,19章介绍
>+ 完整性控制技术(Enable constraints)
>+ 安全性控制技术(Authorization and authentication)

本章内容:
>+ 数据库的一致性
>+ 事务的状态及原语操作
>+ 数据库系统故障分析
>+ Undo日志
>+ Redo日志
>+ Undo/Redo日志
>+ Checkpoint
>+ Log Rotation

## 一、数据库的一致性
一致状态(Consistent state:):满足所有完整性约束
一致数据库:满足一致状态的数据库

对于事务需要满足下面关系:
>+ 原子性(Atomicity):同一个事务的语句要么都执行,要么都不执行
>+ 一致性(Consistency):如果事务执行之前为一致状态,则执行后仍然为一致状态
>+ 隔离性(Isolation):事务之间不受影响
>+ 耐用性(Durability):将数据持久化

## 二、事务的状态以及原语操作
### 2.事务的状态:
>+ 开始 \<Start T\>表示事务T开始
>+ 提交 \<Commit T\>表示事务已经完成,并且写回磁盘持久化
>+ 丢弃 \<Abort T\>T事物中断,所有修改取消

### 3.事务的原语操作
>+ Input (x): disk block with x → memory 
>+ Output (x): buffer block with x → disk 
>+ Read (x,t): do input(x) if necessary t ← value of x in buffer 
>+ Write (x,t): do input(x) if necessary value of x in buffer ← t 

## 三、数据库系统的故障分析
可能发生故障的原因:
>+ 事务故障
>+ 介质故障
>+ 系统故障

当故障发生之后,可能会进入非一致状态,此时如果需要回到一致状态,此时可以向前回滚以及向后回滚.
###  事务故障
#### 1. 发生在单个事务内部的故障
>+ 可预期的事务故障：即应用程序可以发现的故障，如转帐时余额不足。由应用程序处理
>+ 非预期的事务故障：如运算溢出、死锁等，导致事务被异常中止。应用程序无法处理此类故障，由系统进行处理

影响较小,只会影响自己,对于可预期的事务错误,通常可以通过在业务逻辑中进行异常检测设置错误陷阱来进行后续处理.
对于数据库的异常处理,与其他的不同之处在于,一旦发生错误,需要回滚到一致状态之后,向用户弹出前段提示

#### 2. 介质故障
>+ 硬故障:一般指磁盘损坏,磁盘数据丢失,整个数据库被破坏,通常情况下除了会影响到当前正在运行的事物,对于其他事务也会存在不可逆的影响

该故障也是最常见的故障,解决办法为不停的做备份,同时日志与数据库分开存

#### 3. 系统故障
>+ 系统故障：软故障（Soft Crash），由于OS、DBMS软件问题或断电等问题导致内存数据丢失，但磁盘数据仍在.

会影响所有**正在运行**的事务，破坏事务状态，但不破坏整个数据库,该错误发生时可能会出现下面的状况:
>+ 1. 未完成事务对数据库的更新可能已部分写入数据库
>+ 2. 已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库

发生错误时,采用的办法通常为重启数据库

#### 4. 数据库系统故障恢复策略
**目的:** 恢复DB到一致状态
**基本原则:** 冗余（Redundancy）(主要针对硬故障)
**实现方法:**
>+ 定期转储整个数据库
>+ 建立事务日志(log)
>+ 通过备份和日志进行恢复

备份可以按照下面的方式进行分类:
>+ 海量备份/增量备份:按照备份范围区分将所有数据都备份(海量备份),或者按照上次不同的文件进行备份(增量备份)
>+ 脱机备份/联机备份:按照备份时是否提供服务分为脱机(不提供服务),联机(提供服务)

当发生故障时一般按照下面的方式来恢复:
>+ （1）若是介质故障，则首先重装副本,此时物理状态恢复到之前的某个节点
>+ （2）利用日志进行事务故障恢复和系统故障恢复，一直恢复到故障发生点

## 四、Undo日志
**事务日志记录了所有更新操作的具体细节**
>+ 日志类型包括:Undo日志、Redo日志、Undo/Redo日志

**日志文件的登记严格按事务执行的时间次序**

**Undo日志文件中的内容**
>+ 事务的开始标记（\<Start T>）
>+ 事务的结束标记（<Commit, T>或\<Abort T>）
>+ 事务的更新操作记录，一般包括以下内容
>>+ 执行操作的事务标识
>>+ 操作对象
>>+ 更新前值（插入为空）

目前数据库中使用Redo日志会多一点,Undo日志少一点

### 1.Undo日志规则
>+ 事务的每一个**修改操作**都生成一个日志记录<T,x, old-value> 
>+ 在x被写到磁盘之前，对应该修改的日志记录**必须已被写到磁盘上(先写日志)** 
>+ 当事务的所有修改结果都已写入磁盘后，将<Commit,T>日志记录写到磁盘上

使用先写日志的方式可以更快的找到数据库是否存在不一致,而先写data无法判断是否一致(但是对于Redo日志则是相反,采用先写数据)

对于实际运行时,日志先存储在内存中,当构成一个page时开始调用写回到磁盘,此时先写一个\<Start T>,都写完之后再写\<Commit T>,如果仅有start无commit此时可能存在不一致的情况出现.

### 2. 基于Undo日志的恢复
>+ 从头扫描日志，找出所有没有\<Commit,T> 或\<Abort,T>的所有事务，放入一个事务列表L中
>+ 从尾部开始扫描日志记录<T,x,v>,如果T∈L，则:
>>+ write(X, v)
>>+ output(X)
>+ For each T∈ L do
>>+ write <Abort,T > to log

### 3. Undo日志总结 
>+ \<T,x,v>记录修改前的旧值 
>+ 写入\<Commit,T>之前必须先将数据写入磁盘
>+ 恢复时忽略已提交事务，只撤销未提交事务有<Commit,T>的事务肯定已写回磁盘

## 五、Redo日志
>+ 在x被写到磁盘之前，对应该修改的Redo日志记录必须已被写到磁盘上 (WAL)
>+ 在数据写回磁盘前先写<Commit,T>日志记录
>+ 日志中的数据修改记录
<T, x, v> - - Now v is the new value

对于Redo操作关注有commit的,因为没有commit一定没有修改,Undo相反

### 2.基于Redo日志的恢复
**恢复的基础**
>+ 没有<Commit,T>记录的操作必定没有改写磁盘 数据，因此在恢复时可以不理会
>>+ Differ from Undo logging
>+ 有<Commit,T>记录的结果可能还未写回磁盘， 因此在恢复时要Redo
>>+ Still differ from Undo logging

### 3.Undo vs. Redo
Undo:立即更新(乐观),内存代价小,恢复代价高,可以提前释放内存,但卡在中间的话undo需要额外IO开销
Redo:延迟更新(悲观),恢复代价小,内存代价高,需要将更新先储存在内存中

## 六、Undo/Redo日志
>+ 在x被写到磁盘之前，对应该修改的日志记录必须已被写到磁盘上 (WAL)
>+ 日志中的数据修改记录<T, x, v, w> 
>>+ v is the old value, w is the new value

### 基于Undo/Redo日志的恢复 
>+ 正向扫描日志，将\<commit>的事务放入 Redo列表中，将没有结束的事务放入Undo 列表 
>+ 反向扫描日志，对于\<T,x,v,w>，若T在 Undo列表中，则 Write(x,v); Output(x) 
>+ 正向扫描日志，对于\<T,x,v,w>，若T在 Redo列表中，则 Write(x,w)； Output(x) 
>+ 对于Undo列表中的T，写入\<abort,T>

恢复时先Undo,后Redo,如果反过来的话会恢复到一个更远的一致状态

## 七、检查点(check point)
undo日志列表最多为同时在线的用户数, 到那时redo日志可能会随着用户增长而增长,如果使用其它方式,其效率不高并且内存占用大

当系统故障发生时，必须扫描日志。需要搜索整个日志来确定UNDO列表和REDO列表,主要有下面几个问题
>+ 搜索过程太耗时，因为日志文件增长很快
>+ 会导致最后产生的REDO列表很大，使恢复过程变得很长
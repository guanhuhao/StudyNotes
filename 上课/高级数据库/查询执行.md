# 查询执行
本章内容:
>+ 物理查询计划操作符
>+ 连接操作的实现算法
>>+ 嵌套循环连接
>>+ 归并连接
>>+ 索引连接
>>+ 散列连接
>+ 连接算法的I/O代价估计
>+ 连接顺序选择

## 一、物理查询计划操作符
### 物理操作:  
>+ 逻辑操作符的特定实现(如选择/投影/自然连接等)
>+ 表扫描：TableScan
>+ 排序扫描：SortScan
>+ 索引扫描：IndexScan

### 物理操作符的执行算法

根据数据读取方式分类:
>+ 一趟算法
>+ 两趟算法
>+ 多趟算法

按底层算法分类:
>+ 基于排序的算法
>+ 基于散列的算法
>+ 基于索引的算法

## 二、连接操作(Join)的实现算法
涉及的连接方式$R1(A,C)\bowtie R2(C,D)$:
>+ 嵌套循环连接 (Nested loops join or Iteration join)
>+ 归并连接 (Merge join or Sort join)
>+ 索引连接 (Index join)
>+ 散列连接 (Hash join)

### 1.嵌套循环连接
算法流程可以表示为:
```c++
For each r ∈ R1 Do 
    For each s ∈ R2 do 
        If r.C = s.C Then output r, s pair
```
分别遍历两表找到对应可以连接的元素,复杂度略高为两表大小乘积$O(nm)$,但是不依赖运行环境以及介质,因此作为最基础的连接,一般数据库内都包含

### 2.归并连接
要求按连接元素有序如果无序则先进行排序:
```c++
While (i ≤ T(R1)) ∧ (j ≤ T(R2)) do { 
    if R1[ i ].C = R2[ j ].C then 
        OutputTuples; 
    else if R1[ i ].C > R2[ j ].C then 
        j ← j+1; 
    else if R1[ i ].C < R2[ j ].C then 
        i ← i+1; 
}
```
通常情况下排序需要使用总用时的$\frac{4}{5}$,但是一旦排好顺序,则可以一趟算法直接解决

### 3.索引连接
其算法流程如下:
```c++
For each r ∈ R1 do { 
    X ← index (R2, C, r.C) 
    For each s ∈ X do 
        Output r,s pair
}
Note: X ← index(rel, attr, value) then 
    X = set of rel tuples with attr = value
```
要求在R2上有索引,相当于对嵌套循环连接的优化,使用索引结构优化查找时间,在最坏情况下(当X为R2全集),索引连接算法会比嵌套循环连接算法复杂度高(多了一次索引代价).
对于索引连接中,通常注重对索引的研究

### 4.散列连接
先hash后join,对于相同主键,其对应的可以连接的主键会被划分到相同的桶中,因此减少了对全表的遍历,减少开销,其算法流程如下:
```c++
Algorithm 
(1) Hash R1 tuples into G buckets 
(2) Hash R2 tuples into H buckets 
(3) For i = 0 to k do match tuples in Gi, Hi buckets
Note:R1,R2使用相同的hash函数
```
对于hash增加的代价,可以达到整体查询的$\frac{2}{3}$,对于hash处理系统可以通过下面的方式来辅助理解.
![](./15pic/1.png)
对于k的选择通常情况下选择内存可以容纳的情况下尽可能大的空间,对于从原始数据中读取数据后进行hash处理,存放到对应的内存hash块中,当内存hash块满时,将其写回到桶中(提高利用率防止碎片)
代价分析:读一次,写一次,因此是两遍算法

## 三、连接算法的代价分析
影响连接算法代价(I/O)的因素:
>+ 关系的元组是否在磁盘块中连续存放？(contiguous?)
>+ 关系是否按连接属性有序？ (ordered?)
>+ 连接属性上是否存在索引？ (indexed?)

**情况一:不连续**
> 设:
T(R1) = 10,000 T(R2) = 5,000
S(R1) = S(R2) =1/10 block --元组大小
MEM = 101 blocks

朴素算法:对于每一个R1,每次拿出所有R2中所有元素进行对比,其总代价为:
$$T(R1)*[1+T(R2)]=10000*(1+5000)$$

改进后的算法(嵌套循环算法):将内存读满,如100个blobk读R1的元素,剩下的空间将R2依次读完,则总代价为:
$$
\frac{T(R1)}{(MEM-1)/S(R1)}*[T(R2)+(MEM-1)/S(R1)]=\frac{10000}{100/0.1}*[5000+1000]=60000
$$

进一步改进:考虑交换R1,R2,如果R2\< R1则可以更优

**情况二:连续存放**
那么对于上式所有T(R)都乘*S(R2),如对于该例子相当于所有T(R)缩小10倍

**情况三:连续且有序**
相当于R1,R2分别读取一次,因此总代价为:
$$
\frac{T(R1)}{S(R1)}+\frac{T(R2)}{S(R2)}=1000+500
$$

**情况四:连续且无序**
先排序,排序方法一般选择两阶段多路归并排序,两阶段过程如下:
>+ (i) For each 100 blocks of R: 
>>+ Read into memory 
>>+ Sort in memory 
>>+ Write to disk as a chunk 
>+ (ii) Read all chunks + merge + write out

阶段一:局部排序,写入chunk
阶段二:有序chunk的进行merge,进行merge的原理可以理解为,此时所有chunk的第一个元素中一定包含最小的元素将其剔除后可以得到次小的一次类推

整体代价分析:第一阶段读一次写一次,代价为两倍R,阶段二也是读一次写一次因此还是2R,再加上连接的R,因此总代价可以表示为下式,如果不连续存放则对应的R需要替换为对应T(R):
$$
Cost = 5[B(R1)+B(R2)]
$$
归并连接是一个三趟算法

对比:
嵌套循环连接是固有的二次算法，而归并连接是一次算法，当关系较小时，嵌套循环连接可能优于归并连接，但当关系较大时，归并连接更优。

归并排序的条件:
Buffer block数的平方必须大于等于排序关系R的块数B(R),否则两阶段不能完成,需要再进行几次


### 2. 归并连接改进
将第二阶段排序与join合并
>+ (1) Read R1 and R2 into sorted chunks (each has M blocks) 
>+ (2) Read first blocks of both R1’s chunks and R2’s into buffer 
>+ (3) Join in the memory

对于阶段二同时读取R1,R2,merge之后,直接在内存中进行连接,不写回到磁盘,因此减少2次IO,但是需要更大的内存,要求内存可存放元组块M:
$$
R1 + R2 ≤ M
$$
此时总IO代价为3倍的(R1+R2)

### 3. 索引连接算法代价分析
情况一:以R1.C为主键的索引存在
算法流程如下:
```c++
for each R2 tuple: 
    probe index on R1.C (1) 
    if match, 
        read R1 tuple   (2)
```
代价分析:
定义p为选中率,即对于一个R2有多少个R1元组与其具有相同键值,如果R1为主键,那么一个R2存在且唯一有一个R1与其对应,此时p=1,如果R1均匀散列在R2对应的键值上,那么选中率p=10000/5000=2
那么对于索引连接算法的代价估计可以写为:
$$
Cost = B(R2)+T(R2)*p
$$

情况二:如果R1的索引不能全部放入内存
那么需要在上式的基础上添加额外的平均索引读取开销,假设内存有$MEM$块,索引占用$IDX$空间,那么额外开销$EX$可以表示为:
$$
EX = \sum_{i=0}^{\lceil IDX/MEM\rceil} i*\frac{1}{\lceil IDX/MEM\rceil}
$$
对应的上式可以表示为:
$$
Cost = B(R2)+[T(R2)+EX]*p
$$

### 4.散列连接代价分析
算法流程
```c++
(1)Read R1, Hash, Write into buckets 
(2)Read R2, Hash, Write into buckets 
(3)Repeat 
    ① Read one bucket of R2 (say B(R2)≤ B(R1)) 
    ② Read corresponding R1 bucket 
    ③ Join in the memory
```
简述:
将R1,R2分别读取,并写入到对应hash后的桶中,之后分别对具有相同hash值的R1,R2桶中的元素尝试进行判定以及连接

代价分析:
分为创建桶,以及Join操作,在创建桶的过程中需要分别读写一次,对于Join操作需要从桶中读取一遍元素,因此总代价为3遍IO开销即:
$$
Cost = 3*[B(R1)+B(R2)]
$$

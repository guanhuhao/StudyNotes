# 查询执行
本章内容:
>+ 物理查询计划操作符
>+ 连接操作的实现算法
>>+ 嵌套循环连接
>>+ 归并连接
>>+ 索引连接
>>+ 散列连接
>+ 连接算法的I/O代价估计
>+ 连接顺序选择

## 一、物理查询计划操作符
### 物理操作:  
>+ 逻辑操作符的特定实现(如选择/投影/自然连接等)
>+ 表扫描：TableScan
>+ 排序扫描：SortScan
>+ 索引扫描：IndexScan

### 物理操作符的执行算法

根据数据读取方式分类:
>+ 一趟算法
>+ 两趟算法
>+ 多趟算法

按底层算法分类:
>+ 基于排序的算法
>+ 基于散列的算法
>+ 基于索引的算法

## 二、连接操作(Join)的实现算法
涉及的连接方式$R1(A,C)\bowtie R2(C,D)$:
>+ 嵌套循环连接 (Nested loops join or Iteration join)
>+ 归并连接 (Merge join or Sort join)
>+ 索引连接 (Index join)
>+ 散列连接 (Hash join)

### 1.嵌套循环连接
算法流程可以表示为:
```c++
For each r ∈ R1 Do 
    For each s ∈ R2 do 
        If r.C = s.C Then output r, s pair
```
分别遍历两表找到对应可以连接的元素,复杂度略高为两表大小乘积$O(nm)$,但是不依赖运行环境以及介质,因此作为最基础的连接,一般数据库内都包含

### 2.归并连接
要求按连接元素有序如果无序则先进行排序:
```c++
While (i ≤ T(R1)) ∧ (j ≤ T(R2)) do { 
    if R1[ i ].C = R2[ j ].C then 
        OutputTuples; 
    else if R1[ i ].C > R2[ j ].C then 
        j ← j+1; 
    else if R1[ i ].C < R2[ j ].C then 
        i ← i+1; 
}
```
通常情况下排序需要使用总用时的$\frac{4}{5}$,但是一旦排好顺序,则可以一趟算法直接解决

### 3.索引连接
其算法流程如下:
```c++
For each r ∈ R1 do { 
    X ← index (R2, C, r.C) 
    For each s ∈ X do 
        Output r,s pair
}
Note: X ← index(rel, attr, value) then 
    X = set of rel tuples with attr = value
```
要求在R2上有索引,相当于对嵌套循环连接的优化,使用索引结构优化查找时间,在最坏情况下(当X为R2全集),索引连接算法会比嵌套循环连接算法复杂度高(多了一次索引代价).
对于索引连接中,通常注重对索引的研究

### 4.散列连接
先hash后join,对于相同主键,其对应的可以连接的主键会被划分到相同的桶中,因此减少了对全表的遍历,减少开销,其算法流程如下:
```c++
Algorithm 
(1) Hash R1 tuples into G buckets 
(2) Hash R2 tuples into H buckets 
(3) For i = 0 to k do match tuples in Gi, Hi buckets
Note:R1,R2使用相同的hash函数
```
对于hash增加的代价,可以达到整体查询的$\frac{2}{3}$,对于hash处理系统可以通过下面的方式来辅助理解.
![](./15pic/1.png)
对于k的选择通常情况下选择内存可以容纳的情况下尽可能大的空间,对于从原始数据中读取数据后进行hash处理,存放到对应的内存hash块中,当内存hash块满时,将其写回到桶中(提高利用率防止碎片)
代价分析:读一次,写一次,因此是两遍算法

## 三、连接算法的代价分析
影响连接算法代价(I/O)的因素:
>+ 关系的元组是否在磁盘块中连续存放？(contiguous?)
>+ 关系是否按连接属性有序？ (ordered?)
>+ 连接属性上是否存在索引？ (indexed?)

**情况一:不连续**
> 设:
T(R1) = 10,000 T(R2) = 5,000
S(R1) = S(R2) =1/10 block --元组大小
MEM = 101 blocks

朴素算法:对于每一个R1,每次拿出所有R2中所有元素进行对比,其总代价为:
$$T(R1)*[1+T(R2)]=10000*(1+5000)$$

改进后的算法(嵌套循环算法):将内存读满,如100个blobk读R1的元素,剩下的空间将R2依次读完,则总代价为:
$$
\frac{T(R1)}{(MEM-1)/S(R1)}*[T(R2)+(MEM-1)/S(R1)]=\frac{10000}{100/0.1}*[5000+1000]=60000
$$

进一步改进:考虑交换R1,R2,如果R2\< R1则可以更优

**情况二:连续存放**
那么对于上式所有T(R)都乘*S(R2),如对于该例子相当于所有T(R)缩小10倍

**情况三:连续且有序**
相当于R1,R2分别读取一次,因此总代价为:
$$
\frac{T(R1)}{S(R1)}+\frac{T(R2)}{S(R2)}=1000+500
$$

**情况四:连续且无序**
先排序,排序方法一般选择两阶段多路归并排序,两阶段过程如下:
>+ (i) For each 100 blocks of R: 
>>+ Read into memory 
>>+ Sort in memory 
>>+ Write to disk as a chunk 
>+ (ii) Read all chunks + merge + write out

阶段一:局部排序,写入chunk
阶段二:有序chunk的进行merge,进行merge的原理可以理解为,此时所有chunk的第一个元素中一定包含最小的元素将其剔除后可以得到次小的一次类推

整体代价分析:第一阶段读一次写一次,代价为两倍R,阶段二也是读一次写一次因此还是2R,再加上连接的R,因此总代价可以表示为下式,如果不连续存放则对应的R需要替换为对应T(R):
$$
Cost = 5[B(R1)+B(R2)]
$$
归并连接是一个三趟算法

对比:
嵌套循环连接是固有的二次算法，而归并连接是一次算法，当关系较小时，嵌套循环连接可能优于归并连接，但当关系较大时，归并连接更优。

归并排序的条件:
Buffer block数的平方必须大于等于排序关系R的块数B(R),否则两阶段不能完成,需要再进行几次


### 2. 归并连接改进
将第二阶段排序与join合并
>+ (1) Read R1 and R2 into sorted chunks (each has M blocks) 
>+ (2) Read first blocks of both R1’s chunks and R2’s into buffer 
>+ (3) Join in the memory

对于阶段二同时读取R1,R2,merge之后,直接在内存中进行连接,不写回到磁盘,因此减少2次IO,但是需要更大的内存,要求内存可存放元组块M:
$$
R1 + R2 ≤ M
$$
此时总IO代价为3倍的(R1+R2)

### 3. 索引连接算法代价分析
情况一:以R1.C为主键的索引存在
算法流程如下:
```c++
for each R2 tuple: 
    probe index on R1.C (1) 
    if match, 
        read R1 tuple   (2)
```
代价分析:
定义p为选中率,即对于一个R2有多少个R1元组与其具有相同键值,如果R1为主键,那么一个R2存在且唯一有一个R1与其对应,此时p=1,如果R1均匀散列在R2对应的键值上,那么选中率p=10000/5000=2
那么对于索引连接算法的代价估计可以写为:
$$
Cost = B(R2)+T(R2)*p
$$

情况二:如果R1的索引不能全部放入内存
那么需要在上式的基础上添加额外的平均索引读取开销,假设内存有$MEM$块,索引占用$IDX$空间,那么额外开销$EX$可以表示为:
$$
EX = \sum_{i=0}^{\lceil IDX/MEM\rceil} i*\frac{1}{\lceil IDX/MEM\rceil}
$$
对应的上式可以表示为:
$$
Cost = B(R2)+[T(R2)+EX]*p
$$

### 4.散列连接代价分析
算法流程
```c++
(1)Read R1, Hash, Write into buckets 
(2)Read R2, Hash, Write into buckets 
(3)Repeat 
    ① Read one bucket of R2 (say B(R2)≤ B(R1)) 
    ② Read corresponding R1 bucket 
    ③ Join in the memory
```
简述:
将R1,R2分别读取,并写入到对应hash后的桶中,之后分别对具有相同hash值的R1,R2桶中的元素尝试进行判定以及连接

代价分析:
分为创建桶,以及Join操作,在创建桶的过程中需要分别读写一次,对于Join操作需要从桶中读取一遍元素,因此总代价为3遍IO开销即:
$$
Cost = 3*[B(R1)+B(R2)]
$$

## 四、连接顺序的选择
### 1.连接的左右变元
定义:对于$R1(A,C)\bowtie R2(C,D)$ 连接时总是将左变元R1读入内存,然后依次读入R2做连接,一般的来说:
>+ 嵌套循环连接:将较小关系作为左变元
>+ 归并连接:使用排序后较小的关系作为左变元
>+ 索引连接:有索引的关系作为右变元
>+ 散列连接:使用较小关系作为左变元,先进行散列然后读入内存

另外的我们对R1,R2分别给出新的定义:
>+ R1又称建立关系（Build Relation）:连接的左变元，连接时首先将其读入内存（1次或多次I/O）
>+ R2又称试探关系（Probe Relation）:连接的右变元，连接时读入Build Relation后，一次一块地读入Probe Relation进行连接

### 2.连接树
对于仅涉及连接的逻辑查询计划,根据连接情况可能不同种类的连接树,主要有以下三种:
>+ 左深树:可以理解为连接关系退化为一条链,与数据结构中左偏树类似
>+ 紧密树:可以理解为平衡树(可能是满的)
>+ 右深树:与左深树类似,不过是右偏的

使用连接顺序选择时我们通常仅考虑左深树,原因如下:
>+ 理由1：给定n个关系的left-deep join tree**数目相对较小**为$O(n!)$，因此在计划枚举时容易搜索
>+ 理由2：基于左深树的连接比其他非左深树的连接**更高效**,因为左变元先读,因此内存开销比右深树小

**从空间复杂度上来说:**
对于左深树在执行过程中任意时刻仅需要在内存中保存2个临时关系,而相同的关系对于右深树来说需要储存n-1个关系

**从时间复杂度来说:**
对于左深树可以避免重复构建中间关系,即左深树的中间关系仅需要构建一次,可以这么理解当连接时内存无法存放R,S所有元组时必须将部分数据写回磁盘保存,而左深树可以利用内存先进行部分元组的合并,并将其丢弃,不用写回磁盘了.
而对于右深树,如果不使用物化,那么由于左变元放在内存不动,那么右边元可能需要循环读入,而由于右边元为一个不实际存在的表,他是通过构建生成的,因此需要重复对右边元进行构建

### 3.动态规划法选择连接顺序
大致思想:
构造并**存储问题子集的代价表**，在求解上一级问题时可以参照下一级问题（子集）的代价，从而**避免重复计算子集代价**，提高问题求解的效率

状态设置:
>+ $T(R)$: R 的大小估计值
>+ $f(R)$: R 的最小代价（我们使用中间关系大小的和 作为代价计算依据） 
>+ R 的最佳计划（连接顺序）

状态转移方程: ：$f(n)=f(n-1)+T(n-1)$

实际流程:
自底向上计算划分的集合代价,当下层推上层时,通过下面已经得到的对应集合代价,枚举当前集合可能由哪几个集合转移而来,进而推出新的集合代价
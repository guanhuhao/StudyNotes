# 并发控制
**目的:** 多个事务同时存取共享的数据库时，如何保证数据库的一致性？
**需要预防的问题:**
>+ 丢失更新(Lost update):不允许发生的情况,两次写操作冲突,导致一个操作被覆写了
>+ 脏读(Dirty read):先写后读,还没写回更新,旧数据被读取了
>+ 不一致分析(Inconsistent analysis):
>>+ 不可重复读(unrepeated read):在事物处理的过程中,要求被操作的对象不会被其他事物修改
>>+ 幻像读(Phantom read):特指别的写操作,使得原先不存在的元组,满足了当前操作,相当于多出来一个幻象对象

**本章主要内容:**
>+ 并发事务调度与可串性(Scheduling and Serializability )
>+ 锁与可串性实现 (Locks)
>+ 死锁 (Dead Lock)
>+ 乐观并发控制 (Optimistic CC)

## 一、并发调度
我们定义串行调度执行的结果是正确的,因此如果存在某一并行调度使得与串行调度的结果相同则称该并行调度是正确的
### 调度的定义
**调度:** 多个事务的读写操作按时间排序的执行序列
**Note:**
调度中每个事务的读**写操作保持原来顺序**(同一事务读写操作相对顺序确定)
事务调度时不考虑
>+ 数据库的初始状态 (Initial state)
>+ 事务的语义 (Transaction semantics)

## 二.可串化调度
**前提:** 由事务的一致性可以推导出,串行调度一定是正确的,串行调度即各个事务没有任何操作交错之行
**可串化调度:** 如果某个调度的结果与某一串行调度执行的结果等价,那么称该调度是可串化调度,否则则是不可串调度

如何 **证明一个调度是可串行** 的,本章提供两种方式:
>+ 冲突可串性
>+ 视图可串性

### 1.冲突操作
**冲突操作:** 两操作涉及同一个数据库元素,并且**至少有一个是写操作**
**原因:** 
>+ 如果调度中一对连续操作是冲突的，则意味着如果它们的 执行顺序交换，则**至少会改变其中一个事务**的最终执行结果
>+ 如果两个连续操作不冲突，则可以在调度中交换顺序

### 2.冲突可串
>+ 冲突等价:如果调度S1,S2可以通过一系列非冲突的操作交换得到,则称这两个调度冲突等价
>+ 冲突可串性:如果一个调度与串行调度冲突等价,则称这个调度满足冲突可串性
>+ 定理:度过一个调度满足冲突可串性,则该调度为可串化调度

### 3.优先图
用于进行冲突可串性判断
优先图机构:
>+ 节点:事务
>+ 有向边:$T_i\to T_j$满足$T_i<_s T_j$,即满足事务$T_i,T_j$中分别由操作$A_i$与$A_j$冲突且$A_i$先于$A_j$

如果生成的优先图存在环,则这样的调度为不可串化调度
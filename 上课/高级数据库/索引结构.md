## 索引结构
本章内容:
>+ 顺序文件上的索引
>+ 辅助索引
>+ 一维索引
>>+ B+树
>>+ 散列表 (Hash Tables)
>+ 多维索引
>>+ R-Tree
>>+ 网格文件(Grid File)
>>+ 分段散列函数(Partitioned Hash Func.)

### 1. 顺序文件上的索引
定义:记录按照查找键排序,即按照聚簇进行存储,一般要求无重复键值
#### 1.1 密集索引
定义:
>+ 每个记录都有一个索引项
>+ 索引项按照查找键排序

优点:
>+ 索引项通常比记录小(假设条件,这条不成立时密集索引失效)
>+ 索引可以常驻内存
>+ 查找键值为K的记录是否存在时,无需访问磁盘块

密集索引的缺陷:
>+ 索引占用太多空间(可以使用稀疏索引改进)

#### 1.2 稀疏索引
定义:
>+ 仅有部分记录有索引项
>+ 通常情况下仅为每个数据块第一个记录建索引

优点:
>+ 节省索引空间(对于相同记录,稀疏索引可以使用更少的索引项)
>+ 如果密集索引大于内存空间时,稀疏索引可能在查询性能上更好

缺点:
>+ 无法进行快速的存在性查询,需要访问磁盘块来进行二次确认
>+ 只能建立在顺序索引上

#### 1.3 多级索引
定义:
>+ 建索引的索引

优点:
>+ 一级索引可能还太大,不能常驻内存,而使用多级索引可以常驻内存
>+ 减少磁盘I/O

缺点:
>+ 维护代价很大,需要维护二级索引结构

其他:
>+ 有效条件:一级索引过大不能常驻内存,而二级索引可以
>+ 二级索引仅可使用稀疏索引
>+ 一般不考虑三级以上索引
>>+ 需要维护多级索引结构
>>+ 有更好的索引结构(B+树)

#### 1.4 辅助索引

**主索引（Primary Index）**
>+ 顺序文件上的索引
>+ 记录按索引属性值有序
>+ 根据索引值可以确定记录的位置

**辅助索引**
>+ 数据文件不需要按查找键有序
>+ 根据索引值不能确定记录在文件中的顺序
>+ PS:辅助索引必须为密集索引,因为对于辅助索引通常来说无序,因此对一辅助索引的一级索引通常使用密集索引之后,二级索引可以使用稀疏索引

**间接桶**
>+ 出发点:使用密集索引浪费键值空间
>+ 使用一个两层结构来减少密集索引的重复存储,对于第一层仅记录不重复的键值,其指向一段连续空间,该段连续空间存储具有相同键值的记录地址


#### 1.5 倒排索引
**基础思想**
>+ 应用场景:应用于文档检索，与辅助索引思想类似
>+ 不同之处
>>+ 记录->文档
>>+ 记录查找->文档检索
>>+ 查找键->文档中的词
>+ 思想
>>+ 为每个检索词建立间接桶
>>+ 桶的指针指向检索词所出现的文档

先使用B+树记录单词,然后使用一个桶来进行存储包含该单词的文档偏移量,减少主键重复,再指向所有包含该单词的文档

### 2. B+树
**基础定义:**
>+ 一种树型的多级索引结构
>+ 树的层数与**数据大小相关**，通常为3层
>+ 所有结点格式相同：n个值，n＋1个指针
>+ 所有叶结点位于同一层
>+ 多叉、平衡、索引有序
>+ 查找IO复杂度:树高+1(读取)

#### 叶子结点:
>+ 1个指向相邻叶结点的指针
>+ n对键/指针对
>+ 至少$\lfloor (n+1)/2\rfloor$ 个指针指向键值

#### 中间节点:
>+ n个键值划分n+1个子树
>+ 第 i 个键值是第 i+1 个子树中的最小键值
>+ 至少 $\lfloor (n+1)/2\rfloor$ 个指针指向子树
>+ 根结点至少 2 个指针(防止退化)

#### B+树查找
>+ 从根节点向下直到叶子结点
>+ 在叶子结点顺序查找

#### B+树插入
>+ 查找插入叶结点
>+ 若叶结点中有空闲位置（键），则插入
>+ 若没有空间，则分裂叶结点
>>+ 叶结点的分裂可视作是父结点中插入一个子结点递归向上分裂
>>+ 分裂过程中需要对父结点中的键加以调整
>>+ 例外：若根结点分裂，则需要创建一个新的根结点

#### B+树删除
>+ 查找要删除的键值，并删除之
>+ 若结点的键值填充低于规定值，则调整
>>+ 若相邻的叶结点中键填充高于规定值，则将其中一个键值移到该结点中
>>+ 否则，合并该结点与相邻结点,合并可视作在父结点中删除一个子结点
>>+ 递归向上删除
>+ 若删除的是叶结点中的最小键值，则需对父
结点的键值加以调整


